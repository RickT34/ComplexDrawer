using System;
using System.Collections.Generic;
using System.Drawing;

namespace TRsLib
{
    public class MathEX
    {
        #region Tables
        public static readonly int[] PrimeN = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973, 10007, 10009, 10037, 10039, 10061, 10067, 10069, 10079, 10091, 10093, 10099, 10103, 10111, 10133, 10139, 10141, 10151, 10159, 10163, 10169, 10177, 10181, 10193, 10211, 10223, 10243, 10247, 10253, 10259, 10267, 10271, 10273, 10289, 10301, 10303, 10313, 10321, 10331, 10333, 10337, 10343, 10357, 10369, 10391, 10399, 10427, 10429, 10433, 10453, 10457, 10459, 10463, 10477, 10487, 10499, 10501, 10513, 10529, 10531, 10559, 10567, 10589, 10597, 10601, 10607, 10613, 10627, 10631, 10639, 10651, 10657, 10663, 10667, 10687, 10691, 10709, 10711, 10723, 10729, 10733, 10739, 10753, 10771, 10781, 10789, 10799, 10831, 10837, 10847, 10853, 10859, 10861, 10867, 10883, 10889, 10891, 10903, 10909, 10937, 10939, 10949, 10957, 10973, 10979, 10987, 10993, 11003, 11027, 11047, 11057, 11059, 11069, 11071, 11083, 11087, 11093, 11113, 11117, 11119, 11131, 11149, 11159, 11161, 11171, 11173, 11177, 11197, 11213, 11239, 11243, 11251, 11257, 11261, 11273, 11279, 11287, 11299, 11311, 11317, 11321, 11329, 11351, 11353, 11369, 11383, 11393, 11399, 11411, 11423, 11437, 11443, 11447, 11467, 11471, 11483, 11489, 11491, 11497, 11503, 11519, 11527, 11549, 11551, 11579, 11587, 11593, 11597, 11617, 11621, 11633, 11657, 11677, 11681, 11689, 11699, 11701, 11717, 11719, 11731, 11743, 11777, 11779, 11783, 11789, 11801, 11807, 11813, 11821, 11827, 11831, 11833, 11839, 11863, 11867, 11887, 11897, 11903, 11909, 11923, 11927, 11933, 11939, 11941, 11953, 11959, 11969, 11971, 11981, 11987, 12007, 12011, 12037, 12041, 12043, 12049, 12071, 12073, 12097, 12101, 12107, 12109, 12113, 12119, 12143, 12149, 12157, 12161, 12163, 12197, 12203, 12211, 12227, 12239, 12241, 12251, 12253, 12263, 12269, 12277, 12281, 12289, 12301, 12323, 12329, 12343, 12347, 12373, 12377, 12379, 12391, 12401, 12409, 12413, 12421, 12433, 12437, 12451, 12457, 12473, 12479, 12487, 12491, 12497, 12503, 12511, 12517, 12527, 12539, 12541, 12547, 12553, 12569, 12577, 12583, 12589, 12601, 12611, 12613, 12619, 12637, 12641, 12647, 12653, 12659, 12671, 12689, 12697, 12703, 12713, 12721, 12739, 12743, 12757, 12763, 12781, 12791, 12799, 12809, 12821, 12823, 12829, 12841, 12853, 12889, 12893, 12899, 12907, 12911, 12917, 12919, 12923, 12941, 12953, 12959, 12967, 12973, 12979, 12983, 13001, 13003, 13007, 13009, 13033, 13037, 13043, 13049, 13063, 13093, 13099, 13103, 13109, 13121, 13127, 13147, 13151, 13159, 13163, 13171, 13177, 13183, 13187, 13217, 13219, 13229, 13241, 13249, 13259, 13267, 13291, 13297, 13309, 13313, 13327, 13331, 13337, 13339, 13367, 13381, 13397, 13399, 13411, 13417, 13421, 13441, 13451, 13457, 13463, 13469, 13477, 13487, 13499, 13513, 13523, 13537, 13553, 13567, 13577, 13591, 13597, 13613, 13619, 13627, 13633, 13649, 13669, 13679, 13681, 13687, 13691, 13693, 13697, 13709, 13711, 13721, 13723, 13729, 13751, 13757, 13759, 13763, 13781, 13789, 13799, 13807, 13829, 13831, 13841, 13859, 13873, 13877, 13879, 13883, 13901, 13903, 13907, 13913, 13921, 13931, 13933, 13963, 13967, 13997, 13999, 14009, 14011, 14029, 14033, 14051, 14057, 14071, 14081, 14083, 14087, 14107, 14143, 14149, 14153, 14159, 14173, 14177, 14197, 14207, 14221, 14243, 14249, 14251, 14281, 14293, 14303, 14321, 14323, 14327, 14341, 14347, 14369, 14387, 14389, 14401, 14407, 14411, 14419, 14423, 14431, 14437, 14447, 14449, 14461, 14479, 14489, 14503, 14519, 14533, 14537, 14543, 14549, 14551, 14557, 14561, 14563, 14591, 14593, 14621, 14627, 14629, 14633, 14639, 14653, 14657, 14669, 14683, 14699, 14713, 14717, 14723, 14731, 14737, 14741, 14747, 14753, 14759, 14767, 14771, 14779, 14783, 14797, 14813, 14821, 14827, 14831, 14843, 14851, 14867, 14869, 14879, 14887, 14891, 14897, 14923, 14929, 14939, 14947, 14951, 14957, 14969, 14983, 15013, 15017, 15031, 15053, 15061, 15073, 15077, 15083, 15091, 15101, 15107, 15121, 15131, 15137, 15139, 15149, 15161, 15173, 15187, 15193, 15199, 15217, 15227, 15233, 15241, 15259, 15263, 15269, 15271, 15277, 15287, 15289, 15299, 15307, 15313, 15319, 15329, 15331, 15349, 15359, 15361, 15373, 15377, 15383, 15391, 15401, 15413, 15427, 15439, 15443, 15451, 15461, 15467, 15473, 15493, 15497, 15511, 15527, 15541, 15551, 15559, 15569, 15581, 15583, 15601, 15607, 15619, 15629, 15641, 15643, 15647, 15649, 15661, 15667, 15671, 15679, 15683, 15727, 15731, 15733, 15737, 15739, 15749, 15761, 15767, 15773, 15787, 15791, 15797, 15803, 15809, 15817, 15823, 15859, 15877, 15881, 15887, 15889, 15901, 15907, 15913, 15919, 15923, 15937, 15959, 15971, 15973, 15991, 16001, 16007, 16033, 16057, 16061, 16063, 16067, 16069, 16073, 16087, 16091, 16097, 16103, 16111, 16127, 16139, 16141, 16183, 16187, 16189, 16193, 16217, 16223, 16229, 16231, 16249, 16253, 16267, 16273, 16301, 16319, 16333, 16339, 16349, 16361, 16363, 16369, 16381, 16411, 16417, 16421, 16427, 16433, 16447, 16451, 16453, 16477, 16481, 16487, 16493, 16519, 16529, 16547, 16553, 16561, 16567, 16573, 16603, 16607, 16619, 16631, 16633, 16649, 16651, 16657, 16661, 16673, 16691, 16693, 16699, 16703, 16729, 16741, 16747, 16759, 16763, 16787, 16811, 16823, 16829, 16831, 16843, 16871, 16879, 16883, 16889, 16901, 16903, 16921, 16927, 16931, 16937, 16943, 16963, 16979, 16981, 16987, 16993, 17011, 17021, 17027, 17029, 17033, 17041, 17047, 17053, 17077, 17093, 17099, 17107, 17117, 17123, 17137, 17159, 17167, 17183, 17189, 17191, 17203, 17207, 17209, 17231, 17239, 17257, 17291, 17293, 17299, 17317, 17321, 17327, 17333, 17341, 17351, 17359, 17377, 17383, 17387, 17389, 17393, 17401, 17417, 17419, 17431, 17443, 17449, 17467, 17471, 17477, 17483, 17489, 17491, 17497, 17509, 17519, 17539, 17551, 17569, 17573, 17579, 17581, 17597, 17599, 17609, 17623, 17627, 17657, 17659, 17669, 17681, 17683, 17707, 17713, 17729, 17737, 17747, 17749, 17761, 17783, 17789, 17791, 17807, 17827, 17837, 17839, 17851, 17863, 17881, 17891, 17903, 17909, 17911, 17921, 17923, 17929, 17939, 17957, 17959, 17971, 17977, 17981, 17987, 17989, 18013, 18041, 18043, 18047, 18049, 18059, 18061, 18077, 18089, 18097, 18119, 18121, 18127, 18131, 18133, 18143, 18149, 18169, 18181, 18191, 18199, 18211, 18217, 18223, 18229, 18233, 18251, 18253, 18257, 18269, 18287, 18289, 18301, 18307, 18311, 18313, 18329, 18341, 18353, 18367, 18371, 18379, 18397, 18401, 18413, 18427, 18433, 18439, 18443, 18451, 18457, 18461, 18481, 18493, 18503, 18517, 18521, 18523, 18539, 18541, 18553, 18583, 18587, 18593, 18617, 18637, 18661, 18671, 18679, 18691, 18701, 18713, 18719, 18731, 18743, 18749, 18757, 18773, 18787, 18793, 18797, 18803, 18839, 18859, 18869, 18899, 18911, 18913, 18917, 18919, 18947, 18959, 18973, 18979, 19001, 19009, 19013, 19031, 19037, 19051, 19069, 19073, 19079, 19081, 19087, 19121, 19139, 19141, 19157, 19163, 19181, 19183, 19207, 19211, 19213, 19219, 19231, 19237, 19249, 19259, 19267, 19273, 19289, 19301, 19309, 19319, 19333, 19373, 19379, 19381, 19387, 19391, 19403, 19417, 19421, 19423, 19427, 19429, 19433, 19441, 19447, 19457, 19463, 19469, 19471, 19477, 19483, 19489, 19501, 19507, 19531, 19541, 19543, 19553, 19559, 19571, 19577, 19583, 19597, 19603, 19609, 19661, 19681, 19687, 19697, 19699, 19709, 19717, 19727, 19739, 19751, 19753, 19759, 19763, 19777, 19793, 19801, 19813, 19819, 19841, 19843, 19853, 19861, 19867, 19889, 19891, 19913, 19919, 19927, 19937, 19949, 19961, 19963, 19973, 19979, 19991, 19993, 19997, 20011, 20021, 20023, 20029, 20047, 20051, 20063, 20071, 20089, 20101, 20107, 20113, 20117, 20123, 20129, 20143, 20147, 20149, 20161, 20173, 20177, 20183, 20201, 20219, 20231, 20233, 20249, 20261, 20269, 20287, 20297, 20323, 20327, 20333, 20341, 20347, 20353, 20357, 20359, 20369, 20389, 20393, 20399, 20407, 20411, 20431, 20441, 20443, 20477, 20479, 20483, 20507, 20509, 20521, 20533, 20543, 20549, 20551, 20563, 20593, 20599, 20611, 20627, 20639, 20641, 20663, 20681, 20693, 20707, 20717, 20719, 20731, 20743, 20747, 20749, 20753, 20759, 20771, 20773, 20789, 20807, 20809, 20849, 20857, 20873, 20879, 20887, 20897, 20899, 20903, 20921, 20929, 20939, 20947, 20959, 20963, 20981, 20983, 21001, 21011, 21013, 21017, 21019, 21023, 21031, 21059, 21061, 21067, 21089, 21101, 21107, 21121, 21139, 21143, 21149, 21157, 21163, 21169, 21179, 21187, 21191, 21193, 21211, 21221, 21227, 21247, 21269, 21277, 21283, 21313, 21317, 21319, 21323, 21341, 21347, 21377, 21379, 21383, 21391, 21397, 21401, 21407, 21419, 21433, 21467, 21481, 21487, 21491, 21493, 21499, 21503, 21517, 21521, 21523, 21529, 21557, 21559, 21563, 21569, 21577, 21587, 21589, 21599, 21601, 21611, 21613, 21617, 21647, 21649, 21661, 21673, 21683, 21701, 21713, 21727, 21737, 21739, 21751, 21757, 21767, 21773, 21787, 21799, 21803, 21817, 21821, 21839, 21841, 21851, 21859, 21863, 21871, 21881, 21893, 21911, 21929, 21937, 21943, 21961, 21977, 21991, 21997, 22003, 22013, 22027, 22031, 22037, 22039, 22051, 22063, 22067, 22073, 22079, 22091, 22093, 22109, 22111, 22123, 22129, 22133, 22147, 22153, 22157, 22159, 22171, 22189, 22193, 22229, 22247, 22259, 22271, 22273, 22277, 22279, 22283, 22291, 22303, 22307, 22343, 22349, 22367, 22369, 22381, 22391, 22397, 22409, 22433, 22441, 22447, 22453, 22469, 22481, 22483, 22501, 22511, 22531, 22541, 22543, 22549, 22567, 22571, 22573, 22613, 22619, 22621, 22637, 22639, 22643, 22651, 22669, 22679, 22691, 22697, 22699, 22709, 22717, 22721, 22727, 22739, 22741, 22751, 22769, 22777, 22783, 22787, 22807, 22811, 22817, 22853, 22859, 22861, 22871, 22877, 22901, 22907, 22921, 22937, 22943, 22961, 22963, 22973, 22993, 23003, 23011, 23017, 23021, 23027, 23029, 23039, 23041, 23053, 23057, 23059, 23063, 23071, 23081, 23087, 23099, 23117, 23131, 23143, 23159, 23167, 23173, 23189, 23197, 23201, 23203, 23209, 23227, 23251, 23269, 23279, 23291, 23293, 23297, 23311, 23321, 23327, 23333, 23339, 23357, 23369, 23371, 23399, 23417, 23431, 23447, 23459, 23473, 23497, 23509, 23531, 23537, 23539, 23549, 23557, 23561, 23563, 23567, 23581, 23593, 23599, 23603, 23609, 23623, 23627, 23629, 23633, 23663, 23669, 23671, 23677, 23687, 23689, 23719, 23741, 23743, 23747, 23753, 23761, 23767, 23773, 23789, 23801, 23813, 23819, 23827, 23831, 23833, 23857, 23869, 23873, 23879, 23887, 23893, 23899, 23909, 23911, 23917, 23929, 23957, 23971, 23977, 23981, 23993, 24001, 24007, 24019, 24023, 24029, 24043, 24049, 24061, 24071, 24077, 24083, 24091, 24097, 24103, 24107, 24109, 24113, 24121, 24133, 24137, 24151, 24169, 24179, 24181, 24197, 24203, 24223, 24229, 24239, 24247, 24251, 24281, 24317, 24329, 24337, 24359, 24371, 24373, 24379, 24391, 24407, 24413, 24419, 24421, 24439, 24443, 24469, 24473, 24481, 24499, 24509, 24517, 24527, 24533, 24547, 24551, 24571, 24593, 24611, 24623, 24631, 24659, 24671, 24677, 24683, 24691, 24697, 24709, 24733, 24749, 24763, 24767, 24781, 24793, 24799, 24809, 24821, 24841, 24847, 24851, 24859, 24877, 24889, 24907, 24917, 24919, 24923, 24943, 24953, 24967, 24971, 24977, 24979, 24989, 25013, 25031, 25033, 25037, 25057, 25073, 25087, 25097, 25111, 25117, 25121, 25127, 25147, 25153, 25163, 25169, 25171, 25183, 25189, 25219, 25229, 25237, 25243, 25247, 25253, 25261, 25301, 25303, 25307, 25309, 25321, 25339, 25343, 25349, 25357, 25367, 25373, 25391, 25409, 25411, 25423, 25439, 25447, 25453, 25457, 25463, 25469, 25471, 25523, 25537, 25541, 25561, 25577, 25579, 25583, 25589, 25601, 25603, 25609, 25621, 25633, 25639, 25643, 25657, 25667, 25673, 25679, 25693, 25703, 25717, 25733, 25741, 25747, 25759, 25763, 25771, 25793, 25799, 25801, 25819, 25841, 25847, 25849, 25867, 25873, 25889, 25903, 25913, 25919, 25931, 25933, 25939, 25943, 25951, 25969, 25981, 25997, 25999, 26003, 26017, 26021, 26029, 26041, 26053, 26083, 26099, 26107, 26111, 26113, 26119, 26141, 26153, 26161, 26171, 26177, 26183, 26189, 26203, 26209, 26227, 26237, 26249, 26251, 26261, 26263, 26267, 26293, 26297, 26309, 26317, 26321, 26339, 26347, 26357, 26371, 26387, 26393, 26399, 26407, 26417, 26423, 26431, 26437, 26449, 26459, 26479, 26489, 26497, 26501, 26513, 26539, 26557, 26561, 26573, 26591, 26597, 26627, 26633, 26641, 26647, 26669, 26681, 26683, 26687, 26693, 26699, 26701, 26711, 26713, 26717, 26723, 26729, 26731, 26737, 26759, 26777, 26783, 26801, 26813, 26821, 26833, 26839, 26849, 26861, 26863, 26879, 26881, 26891, 26893, 26903, 26921, 26927, 26947, 26951, 26953, 26959, 26981, 26987, 26993, 27011, 27017, 27031, 27043, 27059, 27061, 27067, 27073, 27077, 27091, 27103, 27107, 27109, 27127, 27143, 27179, 27191, 27197, 27211, 27239, 27241, 27253, 27259, 27271, 27277, 27281, 27283, 27299, 27329, 27337, 27361, 27367, 27397, 27407, 27409, 27427, 27431, 27437, 27449, 27457, 27479, 27481, 27487, 27509, 27527, 27529, 27539, 27541, 27551, 27581, 27583, 27611, 27617, 27631, 27647, 27653, 27673, 27689, 27691, 27697, 27701, 27733, 27737, 27739, 27743, 27749, 27751, 27763, 27767, 27773, 27779, 27791, 27793, 27799, 27803, 27809, 27817, 27823, 27827, 27847, 27851, 27883, 27893, 27901, 27917, 27919, 27941, 27943, 27947, 27953, 27961, 27967, 27983, 27997, 28001, 28019, 28027, 28031, 28051, 28057, 28069, 28081, 28087, 28097, 28099, 28109, 28111, 28123, 28151, 28163, 28181, 28183, 28201, 28211, 28219, 28229, 28277, 28279, 28283, 28289, 28297, 28307, 28309, 28319, 28349, 28351, 28387, 28393, 28403, 28409, 28411, 28429, 28433, 28439, 28447, 28463, 28477, 28493, 28499, 28513, 28517, 28537, 28541, 28547, 28549, 28559, 28571, 28573, 28579, 28591, 28597, 28603, 28607, 28619, 28621, 28627, 28631, 28643, 28649, 28657, 28661, 28663, 28669, 28687, 28697, 28703, 28711, 28723, 28729, 28751, 28753, 28759, 28771, 28789, 28793, 28807, 28813, 28817, 28837, 28843, 28859, 28867, 28871, 28879, 28901, 28909, 28921, 28927, 28933, 28949, 28961, 28979, 29009, 29017, 29021, 29023, 29027, 29033, 29059, 29063, 29077, 29101, 29123, 29129, 29131, 29137, 29147, 29153, 29167, 29173, 29179, 29191, 29201, 29207, 29209, 29221, 29231, 29243, 29251, 29269, 29287, 29297, 29303, 29311, 29327, 29333, 29339, 29347, 29363, 29383, 29387, 29389, 29399, 29401, 29411, 29423, 29429, 29437, 29443, 29453, 29473, 29483, 29501, 29527, 29531, 29537, 29567, 29569, 29573, 29581, 29587, 29599, 29611, 29629, 29633, 29641, 29663, 29669, 29671, 29683, 29717, 29723, 29741, 29753, 29759, 29761, 29789, 29803, 29819, 29833, 29837, 29851, 29863, 29867, 29873, 29879, 29881, 29917, 29921, 29927, 29947, 29959, 29983, 29989, 30011, 30013, 30029, 30047, 30059, 30071, 30089, 30091, 30097, 30103, 30109, 30113, 30119, 30133, 30137, 30139, 30161, 30169, 30181, 30187, 30197, 30203, 30211, 30223, 30241, 30253, 30259, 30269, 30271, 30293, 30307, 30313, 30319, 30323, 30341, 30347, 30367, 30389, 30391, 30403, 30427, 30431, 30449, 30467, 30469, 30491, 30493, 30497, 30509, 30517, 30529, 30539, 30553, 30557, 30559, 30577, 30593, 30631, 30637, 30643, 30649, 30661, 30671, 30677, 30689, 30697, 30703, 30707, 30713, 30727, 30757, 30763, 30773, 30781, 30803, 30809, 30817, 30829, 30839, 30841, 30851, 30853, 30859, 30869, 30871, 30881, 30893, 30911, 30931, 30937, 30941, 30949, 30971, 30977, 30983, 31013, 31019, 31033, 31039, 31051, 31063, 31069, 31079, 31081, 31091, 31121, 31123, 31139, 31147, 31151, 31153, 31159, 31177, 31181, 31183, 31189, 31193, 31219, 31223, 31231, 31237, 31247, 31249, 31253, 31259, 31267, 31271, 31277, 31307, 31319, 31321, 31327, 31333, 31337, 31357, 31379, 31387, 31391, 31393, 31397, 31469, 31477, 31481, 31489, 31511, 31513, 31517, 31531, 31541, 31543, 31547, 31567, 31573, 31583, 31601, 31607, 31627, 31643, 31649, 31657, 31663, 31667, 31687, 31699, 31721, 31723, 31727, 31729, 31741, 31751, 31769, 31771, 31793, 31799, 31817, 31847, 31849, 31859, 31873, 31883, 31891, 31907, 31957, 31963, 31973, 31981, 31991, 32003, 32009, 32027, 32029, 32051, 32057, 32059, 32063, 32069, 32077, 32083, 32089, 32099, 32117, 32119, 32141, 32143, 32159, 32173, 32183, 32189, 32191, 32203, 32213, 32233, 32237, 32251, 32257, 32261, 32297, 32299, 32303, 32309, 32321, 32323, 32327, 32341, 32353, 32359, 32363, 32369, 32371, 32377, 32381, 32401, 32411, 32413, 32423, 32429, 32441, 32443, 32467, 32479, 32491, 32497, 32503, 32507, 32531, 32533, 32537, 32561, 32563, 32569, 32573, 32579, 32587, 32603, 32609, 32611, 32621, 32633, 32647, 32653, 32687, 32693, 32707, 32713, 32717, 32719, 32749, 32771, 32779, 32783, 32789, 32797, 32801, 32803, 32831, 32833, 32839, 32843, 32869, 32887, 32909, 32911, 32917, 32933, 32939, 32941, 32957, 32969, 32971, 32983, 32987, 32993, 32999, 33013, 33023, 33029, 33037, 33049, 33053, 33071, 33073, 33083, 33091, 33107, 33113, 33119, 33149, 33151, 33161, 33179, 33181, 33191, 33199, 33203, 33211, 33223, 33247, 33287, 33289, 33301, 33311, 33317, 33329, 33331, 33343, 33347, 33349, 33353, 33359, 33377, 33391, 33403, 33409, 33413, 33427, 33457, 33461, 33469, 33479, 33487, 33493, 33503, 33521, 33529, 33533, 33547, 33563, 33569, 33577, 33581, 33587, 33589, 33599, 33601, 33613, 33617, 33619, 33623, 33629, 33637, 33641, 33647, 33679, 33703, 33713, 33721, 33739, 33749, 33751, 33757, 33767, 33769, 33773, 33791, 33797, 33809, 33811, 33827, 33829, 33851, 33857, 33863, 33871, 33889, 33893, 33911, 33923, 33931, 33937, 33941, 33961, 33967, 33997, 34019, 34031, 34033, 34039, 34057, 34061, 34123, 34127, 34129, 34141, 34147, 34157, 34159, 34171, 34183, 34211, 34213, 34217, 34231, 34253, 34259, 34261, 34267, 34273, 34283, 34297, 34301, 34303, 34313, 34319, 34327, 34337, 34351, 34361, 34367, 34369, 34381, 34403, 34421, 34429, 34439, 34457, 34469, 34471, 34483, 34487, 34499, 34501, 34511, 34513, 34519, 34537, 34543, 34549, 34583, 34589, 34591, 34603, 34607, 34613, 34631, 34649, 34651, 34667, 34673, 34679, 34687, 34693, 34703, 34721, 34729, 34739, 34747, 34757, 34759, 34763, 34781, 34807, 34819, 34841, 34843, 34847, 34849, 34871, 34877, 34883, 34897, 34913, 34919, 34939, 34949, 34961, 34963, 34981, 35023, 35027, 35051, 35053, 35059, 35069, 35081, 35083, 35089, 35099, 35107, 35111, 35117, 35129, 35141, 35149, 35153, 35159, 35171, 35201, 35221, 35227, 35251, 35257, 35267, 35279, 35281, 35291, 35311, 35317, 35323, 35327, 35339, 35353, 35363, 35381, 35393, 35401, 35407, 35419, 35423, 35437, 35447, 35449, 35461, 35491, 35507, 35509, 35521, 35527, 35531, 35533, 35537, 35543, 35569, 35573, 35591, 35593, 35597, 35603, 35617, 35671, 35677, 35729, 35731, 35747, 35753, 35759, 35771, 35797, 35801, 35803, 35809, 35831, 35837, 35839, 35851, 35863, 35869, 35879, 35897, 35899, 35911, 35923, 35933, 35951, 35963, 35969, 35977, 35983, 35993, 35999, 36007, 36011, 36013, 36017, 36037, 36061, 36067, 36073, 36083, 36097, 36107, 36109, 36131, 36137, 36151, 36161, 36187, 36191, 36209, 36217, 36229, 36241, 36251, 36263, 36269, 36277, 36293, 36299, 36307, 36313, 36319, 36341, 36343, 36353, 36373, 36383, 36389, 36433, 36451, 36457, 36467, 36469, 36473, 36479, 36493, 36497, 36523, 36527, 36529, 36541, 36551, 36559, 36563, 36571, 36583, 36587, 36599, 36607, 36629, 36637, 36643, 36653, 36671, 36677, 36683, 36691, 36697, 36709, 36713, 36721, 36739, 36749, 36761, 36767, 36779, 36781, 36787, 36791, 36793, 36809, 36821, 36833, 36847, 36857, 36871, 36877, 36887, 36899, 36901, 36913, 36919, 36923, 36929, 36931, 36943, 36947, 36973, 36979, 36997, 37003, 37013, 37019, 37021, 37039, 37049, 37057, 37061, 37087, 37097, 37117, 37123, 37139, 37159, 37171, 37181, 37189, 37199, 37201, 37217, 37223, 37243, 37253, 37273, 37277, 37307, 37309, 37313, 37321, 37337, 37339, 37357, 37361, 37363, 37369, 37379, 37397, 37409, 37423, 37441, 37447, 37463, 37483, 37489, 37493, 37501, 37507, 37511, 37517, 37529, 37537, 37547, 37549, 37561, 37567, 37571, 37573, 37579, 37589, 37591, 37607, 37619, 37633, 37643, 37649, 37657, 37663, 37691, 37693, 37699, 37717, 37747, 37781, 37783, 37799, 37811, 37813, 37831, 37847, 37853, 37861, 37871, 37879, 37889, 37897, 37907, 37951, 37957, 37963, 37967, 37987, 37991, 37993, 37997, 38011, 38039, 38047, 38053, 38069, 38083, 38113, 38119, 38149, 38153, 38167, 38177, 38183, 38189, 38197, 38201, 38219, 38231, 38237, 38239, 38261, 38273, 38281, 38287, 38299, 38303, 38317, 38321, 38327, 38329, 38333, 38351, 38371, 38377, 38393, 38431, 38447, 38449, 38453, 38459, 38461, 38501, 38543, 38557, 38561, 38567, 38569, 38593, 38603, 38609, 38611, 38629, 38639, 38651, 38653, 38669, 38671, 38677, 38693, 38699, 38707, 38711, 38713, 38723, 38729, 38737, 38747, 38749, 38767, 38783, 38791, 38803, 38821, 38833, 38839, 38851, 38861, 38867, 38873, 38891, 38903, 38917, 38921, 38923, 38933, 38953, 38959, 38971, 38977, 38993, 39019, 39023, 39041, 39043, 39047, 39079, 39089, 39097, 39103, 39107, 39113, 39119, 39133, 39139, 39157, 39161, 39163, 39181, 39191, 39199, 39209, 39217, 39227, 39229, 39233, 39239, 39241, 39251, 39293, 39301, 39313, 39317, 39323, 39341, 39343, 39359, 39367, 39371, 39373, 39383, 39397, 39409, 39419, 39439, 39443, 39451, 39461, 39499, 39503, 39509, 39511, 39521, 39541, 39551, 39563, 39569, 39581, 39607, 39619, 39623, 39631, 39659, 39667, 39671, 39679, 39703, 39709, 39719, 39727, 39733, 39749, 39761, 39769, 39779, 39791, 39799, 39821, 39827, 39829, 39839, 39841, 39847, 39857, 39863, 39869, 39877, 39883, 39887, 39901, 39929, 39937, 39953, 39971, 39979, 39983, 39989, 40009, 40013, 40031, 40037, 40039, 40063, 40087, 40093, 40099, 40111, 40123, 40127, 40129, 40151, 40153, 40163, 40169, 40177, 40189, 40193, 40213, 40231, 40237, 40241, 40253, 40277, 40283, 40289, 40343, 40351, 40357, 40361, 40387, 40423, 40427, 40429, 40433, 40459, 40471, 40483, 40487, 40493, 40499, 40507, 40519, 40529, 40531, 40543, 40559, 40577, 40583, 40591, 40597, 40609, 40627, 40637, 40639, 40693, 40697, 40699, 40709, 40739, 40751, 40759, 40763, 40771, 40787, 40801, 40813, 40819, 40823, 40829, 40841, 40847, 40849, 40853, 40867, 40879, 40883, 40897, 40903, 40927, 40933, 40939, 40949, 40961, 40973, 40993, 41011, 41017, 41023, 41039, 41047, 41051, 41057, 41077, 41081, 41113, 41117, 41131, 41141, 41143, 41149, 41161, 41177, 41179, 41183, 41189, 41201, 41203, 41213, 41221, 41227, 41231, 41233, 41243, 41257, 41263, 41269, 41281, 41299, 41333, 41341, 41351, 41357, 41381, 41387, 41389, 41399, 41411, 41413, 41443, 41453, 41467, 41479, 41491, 41507, 41513, 41519, 41521, 41539, 41543, 41549, 41579, 41593, 41597, 41603, 41609, 41611, 41617, 41621, 41627, 41641, 41647, 41651, 41659, 41669, 41681, 41687, 41719, 41729, 41737, 41759, 41761, 41771, 41777, 41801, 41809, 41813, 41843, 41849, 41851, 41863, 41879, 41887, 41893, 41897, 41903, 41911, 41927, 41941, 41947, 41953, 41957, 41959, 41969, 41981, 41983, 41999, 42013, 42017, 42019, 42023, 42043, 42061, 42071, 42073, 42083, 42089, 42101, 42131, 42139, 42157, 42169, 42179, 42181, 42187, 42193, 42197, 42209, 42221, 42223, 42227, 42239, 42257, 42281, 42283, 42293, 42299, 42307, 42323, 42331, 42337, 42349, 42359, 42373, 42379, 42391, 42397, 42403, 42407, 42409, 42433, 42437, 42443, 42451, 42457, 42461, 42463, 42467, 42473, 42487, 42491, 42499, 42509, 42533, 42557, 42569, 42571, 42577, 42589, 42611, 42641, 42643, 42649, 42667, 42677, 42683, 42689, 42697, 42701, 42703, 42709, 42719, 42727, 42737, 42743, 42751, 42767, 42773, 42787, 42793, 42797, 42821, 42829, 42839, 42841, 42853, 42859, 42863, 42899, 42901, 42923, 42929, 42937, 42943, 42953, 42961, 42967, 42979, 42989, 43003, 43013, 43019, 43037, 43049, 43051, 43063, 43067, 43093, 43103, 43117, 43133, 43151, 43159, 43177, 43189, 43201, 43207, 43223, 43237, 43261, 43271, 43283, 43291, 43313, 43319, 43321, 43331, 43391, 43397, 43399, 43403, 43411, 43427, 43441, 43451, 43457, 43481, 43487, 43499, 43517, 43541, 43543, 43573, 43577, 43579, 43591, 43597, 43607, 43609, 43613, 43627, 43633, 43649, 43651, 43661, 43669, 43691, 43711, 43717, 43721, 43753, 43759, 43777, 43781, 43783, 43787, 43789, 43793, 43801, 43853, 43867, 43889, 43891, 43913, 43933, 43943, 43951, 43961, 43963, 43969, 43973, 43987, 43991, 43997, 44017, 44021, 44027, 44029, 44041, 44053, 44059, 44071, 44087, 44089, 44101, 44111, 44119, 44123, 44129, 44131, 44159, 44171, 44179, 44189, 44201, 44203, 44207, 44221, 44249, 44257, 44263, 44267, 44269, 44273, 44279, 44281, 44293, 44351, 44357, 44371, 44381, 44383, 44389, 44417, 44449, 44453, 44483, 44491, 44497, 44501, 44507, 44519, 44531, 44533, 44537, 44543, 44549, 44563, 44579, 44587, 44617, 44621, 44623, 44633, 44641, 44647, 44651, 44657, 44683, 44687, 44699, 44701, 44711, 44729, 44741, 44753, 44771, 44773, 44777, 44789, 44797, 44809, 44819, 44839, 44843, 44851, 44867, 44879, 44887, 44893, 44909, 44917, 44927, 44939, 44953, 44959, 44963, 44971, 44983, 44987, 45007, 45013, 45053, 45061, 45077, 45083, 45119, 45121, 45127, 45131, 45137, 45139, 45161, 45179, 45181, 45191, 45197, 45233, 45247, 45259, 45263, 45281, 45289, 45293, 45307, 45317, 45319, 45329, 45337, 45341, 45343, 45361, 45377, 45389, 45403, 45413, 45427, 45433, 45439, 45481, 45491, 45497, 45503, 45523, 45533, 45541, 45553, 45557, 45569, 45587, 45589, 45599, 45613, 45631, 45641, 45659, 45667, 45673, 45677, 45691, 45697, 45707, 45737, 45751, 45757, 45763, 45767, 45779, 45817, 45821, 45823, 45827, 45833, 45841, 45853, 45863, 45869, 45887, 45893, 45943, 45949, 45953, 45959, 45971, 45979, 45989, 46021, 46027, 46049, 46051, 46061, 46073, 46091, 46093, 46099, 46103, 46133, 46141, 46147, 46153, 46171, 46181, 46183, 46187, 46199, 46219, 46229, 46237, 46261, 46271, 46273, 46279, 46301, 46307, 46309, 46327, 46337 };
        public static readonly int PrimeNL = PrimeN.Length;
        public static readonly int PrimeNMAXS = PrimeN[PrimeNL - 1] * PrimeN[PrimeNL - 1];
        public static readonly int[] SizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, int.MaxValue };
        public static readonly int SizeTableL = SizeTable.Length;
        public static readonly Dictionary<string, double> Consts = new Dictionary<string, double>() { ["PI"] = Math.PI, ["E"] = Math.E };
        #endregion

        #region Structs&Classes
        /// <summary>
        /// 分数结构
        /// </summary>
        public struct QNum
        {
            public static int DoubleRange = 10000;
            /// <summary>
            /// 分子
            /// </summary>
            public int Up;
            /// <summary>
            /// 分母
            /// </summary>
            public int Down;
            public static readonly QNum One = new QNum(1);
            public static readonly QNum Zero = new QNum(0);
            public static readonly QNum Mine = new QNum(-1);
            public static readonly QNum Two = new QNum(2);
            public static readonly QNum Null = new QNum(1, 0, true);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="up">分子</param>
            /// <param name="down">分母</param>
            /// <param name="simpled">是否已是最简分数</param>
            public QNum(int up, int down, bool simpled = false)
            {
                Up = up;
                Down = down;
                if (Down < 0)
                {
                    Up = -Up;
                    Down = -Down;
                }
                if (!simpled) Simpify();
            }
            public QNum(int n)
            {
                this.Up = n;
                this.Down = 1;
            }
            /// <summary>
            /// 会对f近似为分数
            /// </summary>
            /// <param name="f"></param>
            public QNum(double f)
            {
                if (f == 0)
                {
                    Up = 0;
                    Down = 1;
                    return;
                }
                for (int q = 1; q < 10; q++)
                {
                    if (f * q - (int)(f * q) >= 0.99999)
                    {
                        Up = (int)(f * q) + 1;
                        Down = q;
                        return;
                    }
                }
                Down = 100000;
                Up = (int)(f * 100000 + 0.1);
                Simpify();
            }
            /// <summary>
            /// 输入a/b
            /// </summary>
            /// <param name="n"></param>
            public QNum(string n)
            {
                if (n.Contains("."))
                {
                    double f = Convert.ToDouble(n);
                    if (f == 0)
                    {
                        Up = 0;
                        Down = 1;
                        return;
                    }
                    for (int q = 1; q < 10; q++)
                    {
                        if (f * q - (int)(f * q) >= 0.99999)
                        {
                            Up = (int)(f * q) + 1;
                            Down = q;
                            return;
                        }
                    }
                    Down = DoubleRange;
                    Up = (int)(f * DoubleRange + 0.1);
                    Simpify();
                    return;
                }
                int i = n.IndexOf('/');
                if (i == -1)
                {
                    if (n == "-")
                    {
                        Up = -1;
                        Down = 1;
                        return;
                    }
                    Up = Convert.ToInt32(n);
                    Down = 1;
                }
                else
                {
                    Up = Convert.ToInt32(n.Substring(0, i));
                    Down = Convert.ToInt32(n.Substring(i + 1));
                    Simpify();
                }
            }

            public QNum GetMine() => new QNum(Up * -1, Down, true);
            public static bool operator ==(QNum a, QNum b) => a.Up == b.Up && a.Down == b.Down;
            public static bool operator !=(QNum a, QNum b) => a.Up != b.Up || a.Down != b.Down;
            public static QNum operator +(QNum a, QNum b) => new QNum(a.Up * b.Down + b.Up * a.Down, a.Down * b.Down);
            public static QNum operator -(QNum a, QNum b) => new QNum((a.Up * b.Down) - (b.Up * a.Down), a.Down * b.Down);
            public static QNum operator *(QNum a, QNum b) => new QNum(a.Up * b.Up, a.Down * b.Down);
            public static QNum operator /(QNum a, QNum b) => new QNum(a.Up * b.Down, a.Down * b.Up);
            public static QNum operator *(QNum a, int b) => new QNum(a.Up * b, a.Down);
            public static QNum operator +(QNum a, int b) => new QNum(a.Up + a.Down * b, a.Down, true);
            public static QNum operator -(QNum a, int b) => new QNum(a.Up - a.Down * b, a.Down, true);
            public static QNum operator *(QNum a, double b) => new QNum(b) * a;
            public static QNum operator /(QNum a, int b) => new QNum(a.Up, a.Down * b);
            public static HPA operator *(QNum a, HPA b) => new HPA(((int)a.Value).ToString()) + b;
            public static QNum operator ^(QNum a, int b)
            {
                if (b == 0) return QNum.One;
                if (b < 0)
                {
                    a = a.Reciprocal;
                    b = -b;
                }
                return new QNum((int)Math.Pow(a.Up, b), (int)Math.Pow(a.Down, b), true);
            }
            public static QNum operator ^(QNum a, QNum b)
            {
                if (b.Up == 0) return One;
                if (b.Down == 1) return a ^ b.Up;
                return new QNum(Math.Pow(a.Value, b.Value));
            }
            public static bool operator ==(QNum a, int b) => a.Down == 1 && a.Up == b;
            public static bool operator !=(QNum a, int b) => a.Down != 1 || a.Up != b;
            public static bool operator >(QNum a, QNum b) => (a.Up > 0 && b.Up < 0) || a.Up * b.Down > b.Up * a.Down;
            public static bool operator >=(QNum a, QNum b) => (a.Up >= 0 && b.Up <= 0) || a.Up * b.Down >= b.Up * a.Down;
            public static bool operator <=(QNum a, QNum b) => (a.Up <= 0 && b.Up >= 0) || a.Up * b.Down <= b.Up * a.Down;
            public static bool operator <(QNum a, QNum b) => (a.Up < 0 && b.Up > 0) || a.Up * b.Down < b.Up * a.Down;
            public static QNum Abs(QNum a) => new QNum(Math.Abs(a.Up), a.Down, true);
            /// <summary>
            /// 返回分数的倒数
            /// </summary>
            /// <returns></returns>
            public QNum Reciprocal { get => new QNum(Down, Up, true); }
            public double Value { get => (double)Up / Down; }
            /// <summary>
            /// 化简分数
            /// </summary>
            /// <returns></returns>
            public void Simpify()
            {
                int n = Gcd(Down, Up);
                if (n < 0) n = -n;
                if (n == 1) return;
                Up /= n;
                Down /= n;
            }
            public string ToString(bool brief, bool first = false)
            {
                if (Down == 1)
                    return Up >= 0 ? (first ? "" : "+") + (brief ? (Up == 1 ? "" : Up.ToString()) : Up.ToString()) : (brief ? (Up == -1 ? "-" : Up.ToString()) : Up.ToString());
                return (Up >= 0 ? (first ? "" : "+") + Up.ToString() : Up.ToString()) + "/" + this.Down.ToString();
            }
            public override string ToString()
            {
                return ToString(false);
            }
            public static QNum ToQNumWP(string s)
            {
                if (s.Length == 1)
                {
                    if (s == "+") return QNum.One;
                    if (s == "-") return QNum.Mine;
                    return new QNum(s[0] - '0');
                }
                int i = s.IndexOf('('), l;
                if (i != -1)
                {
                    l = MatchKuo(s, i);
                    QNum t = ToQNumWP(s.Substring(i + 1, l - i - 1));
                    if (l < s.Length - 1 && s[l + 1] == '^')
                    {
                        int j = MatchKuo(s, l + 2);
                        QNum tc;
                        if (j != -1) tc = ToQNumWP(s.Substring(l + 3, j - l - 3));
                        else { tc = new QNum(MatchNum(s, l + 2)); j = l + IntRange(tc.Up) + 1; }
                        t ^= tc;
                        l = j;
                    }
                    if (i > 0 && s[i - 1] == '^')
                    {
                        int j = 0;
                        QNum tb = GetQNumWK(s, i - 2, ref j, false);
                        return ToQNumWP(s.Substring(0, j + 1) + (tb ^ t).ToString(false, true) + (l < s.Length - 1 && IsAlpha(s[l + 1]) ? "*" : "") + s.Substring(l + 1));
                    }
                    else return ToQNumWP(s.Substring(0, i)
                                    + (i > 0 && IsAlpha(s[i - 1]) ? "*" : "")
                                    + t.ToString(false, true)
                                    + (l < s.Length - 1 && IsAlpha(s[l + 1]) ? "*" : "")
                                    + s.Substring(l + 1));
                }
                i = s.IndexOf('+');
                if (i != -1 && i != 0) return ToQNumWP(s.Substring(0, i)) + ToQNumWP(s.Substring(i + 1));
                i = s.LastIndexOf('-');
                if (i != -1 && i != 0 && IsAlpha(s[i - 1])) return ToQNumWP(s.Substring(0, i)) - ToQNumWP(s.Substring(i + 1));
                i = s.LastIndexOf('*');
                if (i != -1) return ToQNumWP(s.Substring(0, i)) * ToQNumWP(s.Substring(i + 1));
                i = s.LastIndexOf('/');
                if (i != -1) return ToQNumWP(s.Substring(0, i)) / ToQNumWP(s.Substring(i + 1));
                i = s.IndexOf('^');
                if (i != -1) return ToQNumWP(s.Substring(0, i)) ^ ToQNumWP(s.Substring(i + 1));
                return new QNum(Convert.ToInt32(s));
            }
            public static QNum GetQNumWK(string s, int i, ref int l, bool front = true)
            {
                if (front)
                {
                    if (s[i] == '(')
                    {
                        l = MatchKuo(s, i);
                        return ToQNumWP(s.Substring(i + 1, l - i - 1));
                    }
                    int t = MatchNum(s, i);
                    l = IntRange(t) + i;
                    return new QNum(t);
                }
                else
                {
                    if (s[i] == ')')
                    {
                        l = MatchKuo(s, i);
                        return ToQNumWP(s.Substring(l + 1, i - l - 1));
                    }
                    int t = MatchNum(s, i, false);
                    l = i - IntRange(t);
                    return new QNum(t);
                }
            }
            /// <summary>
            /// 运算，输入符号
            /// </summary>
            /// <param name="a"></param>
            /// <param name="b"></param>
            /// <param name="note"></param>
            /// <returns></returns>
            public static QNum ComputeFromNote(QNum a, QNum b, char note)
            {
                switch (note)
                {
                    case '*':
                        return a * b;
                    case '+':
                        return a + b;
                    case '-':
                        return a - b;
                    case '/':
                        return a / b;
                }
                throw new Exception("No such note:" + note.ToString());
            }
        }
        /// <summary>
        /// 高精度分数类
        /// </summary>
        public class HPAQNum
        {
            public HPA Up;
            public HPA Down;
            public static readonly HPAQNum One = new HPAQNum(QNum.One);
            public static readonly HPAQNum Zero = new HPAQNum(QNum.Zero);
            public static readonly HPAQNum Mine = new HPAQNum(QNum.Mine);
            public static readonly HPAQNum Two = new HPAQNum(QNum.Two);
            public static readonly HPAQNum Null = new HPAQNum(QNum.Null);
            public static readonly HPAQNum PI = new HPAQNum(new HPA("31415926535897931", true), new HPA("10000000000000000", true), true, true);
            public static readonly HPAQNum E = new HPAQNum(new HPA("27182818284590451", true), new HPA("10000000000000000", true), true, true);
            public static int ValueDotLen = 100;
            public static int AccuracyOfFuncton = 80;
            public string Value 
            { 
                get
                {
                    if (Down == HPA.Zero) return "∞";
                    else return HPA.DiviVal(Up, Down, ValueDotLen);
                }
            }
            public string GetValue(int dotlen) => HPA.DiviVal(Up, Down, dotlen);
            public bool pos { get => Up.pos; set { Up.pos = value; } }
            public HPAQNum(HPA up, HPA down, bool onlyclass = false, bool simpled = false)
            {
                if (up == HPA.Zero)
                {
                    if (onlyclass) Up = up;
                    else Up = new HPA(up);
                    Down = new HPA(HPA.One);
                    return;
                }
                if (onlyclass)
                {
                    Up = up;
                    Down = down;
                }
                else
                {
                    Up = new HPA(up);
                    Down = new HPA(down);
                }
                if (!simpled) Simpify();
            }
            public HPAQNum(QNum qNum)
            {
                Up = new HPA(qNum.Up);
                Down = new HPA(qNum.Down);
            }
            public HPAQNum(string s)
            {
                int i = s.IndexOf('.');
                if (i != -1)
                {
                    List<byte> l = new List<byte>();
                    for (int k = 0; k < s.Length - i - 1; k++) l.Add(0);
                    l.Add(1);
                    Down = new HPA(l, true, true, true);
                    Up = new HPA(s.Substring(0, i) + s.Substring(i + 1, s.Length - i - 1));
                }
                else
                {
                    i = s.IndexOf('/');
                    if (i == -1)
                    {
                        Up = new HPA(s);
                        Down = new HPA(HPA.One);
                    }
                    else
                    {
                        Up = new HPA(s.Substring(0, i));
                        Down = new HPA(s.Substring(i + 1));
                    }
                }
                Simpify();
            }
            public HPAQNum(int n)
            {
                Down = new HPA(HPA.One);
                Up = new HPA(n);
            }
            public HPAQNum(HPAQNum hPAQNum)
            {
                Up = new HPA(hPAQNum.Up);
                Down = new HPA(hPAQNum.Down);
            }
            public HPAQNum(HPA n, bool onlyclass = true)
            {
                if (onlyclass) Up = n;
                else Up = new HPA(n);
                Down = new HPA(HPA.One);
            }
            public QNum ToQNum() => new QNum(Convert.ToDouble(Value));
            public int ToInt() => Convert.ToInt32((Up / Down).Num);
            public static bool operator ==(HPAQNum a, HPAQNum b) => a.Equals(b) || (a.Up == b.Up && a.Down == b.Down);
            public static bool operator !=(HPAQNum a, HPAQNum b) => a.Up != b.Up || a.Down != b.Down;
            public static HPAQNum operator +(HPAQNum a, HPAQNum b) => new HPAQNum(a.Up * b.Down + b.Up * a.Down, a.Down * b.Down, true, true);
            public static HPAQNum operator -(HPAQNum a, HPAQNum b) => new HPAQNum((a.Up * b.Down) - (b.Up * a.Down), a.Down * b.Down, true, true);
            public static HPAQNum operator *(HPAQNum a, HPAQNum b) => new HPAQNum(a.Up * b.Up, a.Down * b.Down, true, true);
            public static HPAQNum operator /(HPAQNum a, HPAQNum b) => new HPAQNum(a.Up * b.Down, a.Down * b.Up, true, true);
            public static HPAQNum operator *(HPAQNum a, int b) => new HPAQNum(a.Up * b, a.Down);
            public static HPAQNum operator +(HPAQNum a, int b) => new HPAQNum(a.Up + a.Down * b, a.Down, true, true);
            public static HPAQNum operator -(HPAQNum a, int b) => new HPAQNum(a.Up - a.Down * b, a.Down, true, true);
            public static HPAQNum operator /(HPAQNum a, int b) => new HPAQNum(a.Up, a.Down * b);
            public static HPAQNum operator ^(HPAQNum a, int b) => new HPAQNum(a.Up ^ b, a.Down ^ b, true, true);
            public static HPAQNum operator ^(HPAQNum a, HPA b) => new HPAQNum(a.Up ^ b, a.Down ^ b, true, true);
            public static HPAQNum operator ^(HPAQNum a, HPAQNum b)
            {
                if (b.Up.pos == false)
                {
                    a = new HPAQNum(a.Down, a.Up, true, true);
                    a ^= new HPA(b.Up, true,true);
                }
                else a ^= b.Up;
                if (b.Down != HPA.One) a = PowOp(a, b.Down);
                return a;
            }
            public static HPAQNum operator *(HPAQNum a, QNum b) => new HPAQNum(a.Up * b.Up, a.Down * b.Down, true);
            public static HPAQNum operator /(HPAQNum a, QNum b) => new HPAQNum(a.Up * b.Down, a.Down * b.Up, true);
            public static HPAQNum operator *(HPAQNum a, HPA b) => new HPAQNum(a.Up * b, new HPA(a.Down), true, true);
            public static HPAQNum operator /(HPAQNum a, HPA b) => new HPAQNum(new HPA(a.Up), a.Down * b, true, true);
            public static bool operator >(HPAQNum a, HPAQNum b) => a.Up * b.Down > b.Up * a.Down;
            public static bool operator >=(HPAQNum a, HPAQNum b) => a.Up * b.Down >= b.Up * a.Down;
            public static bool operator <=(HPAQNum a, HPAQNum b) => a.Up * b.Down <= b.Up * a.Down;
            public static bool operator <(HPAQNum a, HPAQNum b) => a.Up * b.Down < b.Up * a.Down;
            public static HPAQNum operator %(HPAQNum a, HPAQNum b)
            {
                if (a < b) return new HPAQNum(a);
                if (a == b) return new HPAQNum(Zero);
                HPAQNum temp = a / b;
                HPA temp2 = temp.Up / temp.Down;
                temp2.pos = b.pos;
                a -= b * temp2;
                return a;
            }
            /// <summary>
            /// 牛顿迭代法开n次方
            /// </summary>
            /// <param name="x">底数</param>
            /// <param name="n">指数</param>
            /// <returns></returns>
            public static HPAQNum PowOp(HPAQNum x, HPA n)
            {
                HPA m = n - HPA.One;
                HPAQNum l = Two, lt = l, ln = new HPAQNum(m, n, true, true);
                bool pos = x.pos;
                x.Up.pos = true;
                while (true)
                {
                    l = ln * l + x / n / (l ^ m);
                    l.Simpify();
                    l.LimitTo(256);
                    //Console.WriteLine(l.Value);
                    lt = l - lt;
                    if (Math.Abs(lt.Down.Len - lt.Up.Len) > AccuracyOfFuncton || lt.Up == HPA.Zero) break;
                    lt = l;
                }
                x.Up.pos = pos;
                l.Up.pos = n.Digitals[0] % 2 == 0 ? true : pos;
                return l;
            }
            public static HPAQNum Ln(HPAQNum x)
            {
                if (x == One) return new HPAQNum(Zero);
                int l = 0;
                while (x >= Two)
                {
                    x = PowOp(x, HPA.Two);
                    l += 1;
                }
                x.LimitTo(64);
                x -= One;
                HPAQNum re = x, temp = re;
                int i = 1;
                while (true)
                {
                    re += ((x ^ (i * 2 + 1)) / (i * 2 + 1)) - ((x ^ (i * 2)) / (i * 2));
                    re.Simpify();
                    re.LimitTo(64);
                    Console.WriteLine(re.Value);
                    i += 1;
                    temp = re - temp;
                    if (Math.Abs(temp.Down.Len - temp.Up.Len) > AccuracyOfFuncton/4 || temp.Up == HPA.Zero) break;
                    temp = re;
                }
                if (l != 0)
                {
                    re *= Two ^ l;
                    re.Simpify();
                }
                return re;
            }
            public static HPAQNum Sin(HPAQNum x, bool deg = true)
            {
                if (deg)
                    x %= new HPAQNum("360");
                else x %= PI;
                return new HPAQNum(Math.Sin(Convert.ToDouble(x.GetValue(15))).ToString());
            }
            public static HPAQNum Cos(HPAQNum x, bool deg = true)
            {
                if (deg)
                    x %= new HPAQNum("360");
                else x %= PI;
                return new HPAQNum(Math.Cos(Convert.ToDouble(x.GetValue(15))).ToString());
            }
            public static HPAQNum Tan(HPAQNum x, bool deg = true)
            {
                if (deg)
                    x %= new HPAQNum("360");
                else x %= PI;
                return new HPAQNum(Math.Tan(Convert.ToDouble(x.GetValue(15))).ToString());
            }
            public void LimitTo(int len)
            {
                while (Up.Digitals.Count > len && Down.Digitals.Count > len)
                {
                    Up.Digitals.RemoveAt(0);
                    Down.Digitals.RemoveAt(0);
                }

            }
            public static HPAQNum ComputePI(int t)
            {
                HPAQNum re = Two;
                Console.WriteLine("Start.");
                for (int i = 1; i < t; i++)
                {
                    re.Up *= new HPA(2 * ((i + 1) / 2));
                    re.Down *= new HPA(2 * (i / 2) + 1);
                    if (i % (t / 10) == 0) Console.WriteLine("Progress: " + ((double)i / t).ToString());
                    if (i % 1000 == 0)
                    {
                        Console.WriteLine("Simpifying..");
                        re.Simpify();
                        Console.WriteLine("Simpify finished.");
                    }
                }
                Console.WriteLine("Compute Finish.Simpifying.");
                re.Simpify();
                return re;
            }
            public void Simpify()
            {
                if (Up == HPA.Zero)
                {
                    if (Down != HPA.One) Down = new HPA(HPA.One);
                    return;
                }
                bool pos = Up.pos == Down.pos;
                Up.pos = Down.pos = true;
                HPA n = HPA.Gcd(Down, Up);
                n.pos = true;
                if (n != HPA.One)
                {
                    Up /= n;
                    Down /= n;
                }
                Up.pos = pos;
                Down.pos = true;
            }
            public string ToString(bool brief, bool first)
            {
                if (Down == HPA.One)
                    return Up.pos ? (first ? "" : "+") + (brief ? (Up == HPA.One ? "" : Up.ToString()) : Up.ToString()) : (brief ? (Up == HPA.Mine ? "-" : Up.ToString()) : Up.ToString());
                return (Up.pos ? (first ? "" : "+") + Up.ToString() : Up.ToString()) + "/" + this.Down.ToString();
            }
            public override string ToString()
            {
                return ToString(false, true);
            }
            public static HPAQNum ToHPAQNumWP(string s)
            {
                if (s.Length == 1)
                {
                    if (s == "+") return new HPAQNum(One);
                    if (s == "-") return new HPAQNum(Mine);
                    return new HPAQNum(s);
                }
                int i = s.IndexOf('('), l;
                if (i != -1)
                {
                    l = MatchKuo(s, i);
                    HPAQNum t = ToHPAQNumWP(s.Substring(i + 1, l - i - 1));
                    if (l < s.Length - 1 && s[l + 1] == '^')
                    {
                        int j = MatchKuo(s, l + 2);
                        HPAQNum tc;
                        if (j != -1) tc = ToHPAQNumWP(s.Substring(l + 3, j - l - 3));
                        else { tc = new HPAQNum(MatchNum(s, l + 2)); j = l + tc.Up.Len + 1; }
                        t ^= tc;
                        l = j;
                    }
                    if (i > 0 && s[i - 1] == '^')
                    {
                        int j = 0;
                        HPAQNum tb = GetHPAQNumWK(s, i - 2, ref j, false);
                        return ToHPAQNumWP(s.Substring(0, j + 1) + (tb ^ t).ToString(false, true) + (l < s.Length - 1 && IsAlpha(s[l + 1]) ? "*" : "") + s.Substring(l + 1));
                    }
                    return ToHPAQNumWP(s.Substring(0, i)
                                    + (i > 0 && IsAlpha(s[i - 1]) ? "*" : "")
                                    + t.ToString()
                                    + (l < s.Length - 1 && IsAlpha(s[l + 1]) ? "*" : "")
                                    + s.Substring(l + 1));
                }
                i = s.IndexOf('+');
                if (i != -1 && i != 0) return ToHPAQNumWP(s.Substring(0, i)) + ToHPAQNumWP(s.Substring(i + 1));
                i = s.LastIndexOf('-');
                if (i != -1 && i != 0 && IsAlpha(s[i - 1])) return ToHPAQNumWP(s.Substring(0, i)) - ToHPAQNumWP(s.Substring(i + 1));
                i = s.LastIndexOf('*');
                if (i != -1) return ToHPAQNumWP(s.Substring(0, i)) * ToHPAQNumWP(s.Substring(i + 1));
                i = s.LastIndexOf('/');
                if (i != -1) return ToHPAQNumWP(s.Substring(0, i)) / ToHPAQNumWP(s.Substring(i + 1));
                i = s.IndexOf('^');
                if (i != -1) return ToHPAQNumWP(s.Substring(0, i)) ^ ToHPAQNumWP(s.Substring(i + 1));
                return new HPAQNum(s);
            }
            public static HPAQNum GetHPAQNumWK(string s, int i, ref int l, bool front = true)
            {
                if (front)
                {
                    if (s[i] == '(')
                    {
                        l = MatchKuo(s, i);
                        return ToHPAQNumWP(s.Substring(i + 1, l - i - 1));
                    }
                    int t = MatchNum(s, i);
                    l = IntRange(t) + i;
                    return new HPAQNum(t);
                }
                else
                {
                    if (s[i] == ')')
                    {
                        l = MatchKuo(s, i);
                        return ToHPAQNumWP(s.Substring(l + 1, i - l - 1));
                    }
                    int t = MatchNum(s, i, false);
                    l = i - IntRange(t);
                    return new HPAQNum(t);
                }
            }
        }
        /// <summary>
        /// 项结构，系数为分数
        /// </summary>
        public struct Item
        {
            /// <summary>
            /// 系数
            /// </summary>
            public QNum qNum;
            /// <summary>
            /// 次数
            /// </summary>
            public int power;
            public static readonly Item Zero = new Item(QNum.Zero);
            public static readonly Item One = new Item(QNum.One);
            public static readonly Item Mine = new Item(QNum.Mine);
            public Item(QNum rNum, int power)
            {
                this.qNum = rNum;
                this.power = power;
            }
            public Item(int up, int down, int power)
            {
                this.qNum = new QNum(up, down);
                this.power = power;
            }
            public Item(int n)
            {
                this.qNum = new QNum(n);
                this.power = 0;
            }
            public Item(QNum n)
            {
                qNum = n;
                power = 0;
            }
            public Item(string s)
            {
                int i = s.IndexOf('x');
                if (i == -1) { power = 0; qNum = new QNum(s); return; }
                power = i < s.Length - 1 ? Convert.ToInt32(s.Substring(i + 2)) : 1;
                qNum = i > 0 ? new QNum(s.Substring(0, i)) : QNum.One;
            }
            public QNum Compute(QNum x) => qNum * (x ^ power);
            public HPA Compute(HPA x) => qNum * (x ^ power);
            public HPAQNum Compute(HPAQNum x) => (x ^ power) * qNum;
            public static bool operator ==(Item a, Item b) => a.power == b.power && a.qNum == b.qNum;
            public static bool operator !=(Item a, Item b) => !(a == b);
            public static Item operator *(Item a, Item b) => new Item(a.qNum * b.qNum, a.power + b.power);
            public static Item operator /(Item a, Item b) => new Item(a.qNum / b.qNum, a.power - b.power);
            public static Item operator *(Item a, QNum b) => new Item(a.qNum * b, a.power = b == QNum.Zero ? 0 : a.power);
            public static Item operator /(Item a, QNum b) => new Item(a.qNum / b, a.power = b == QNum.Zero ? 0 : a.power);
            public static Item operator +(Item a, Item b)
            {
                if (a.power != b.power) throw new Exception("Item + Error!");
                return new Item(a.qNum + b.qNum, a.power);
            }
            public static Item operator -(Item a, Item b)
            {
                if (a.power != b.power) throw new Exception("Item - Error!");
                return new Item(a.qNum - b.qNum, a.power);
            }
            public string ToString(bool first)
            {
                string r;
                r = power == 0 ? qNum.ToString(false) : qNum.ToString(true);
                if (first && r[0] == '+') r = r.Remove(0, 1);
                if (power == 0) return r;
                r += "x" + (power == 1 ? "" : "^" + power.ToString());
                return r;
            }
            public override string ToString()
            {
                return ToString(true);
            }
        }
        /// <summary>
        /// 多系数项
        /// </summary>
        public class ItemEX
        {
            public static readonly ItemEX One = new ItemEX(1);
            public static readonly ItemEX Zero = new ItemEX(0);
            public static readonly ItemEX Mine = new ItemEX(-1);
            public QNum qNum;
            public Dictionary<char, int> itemsWP;
            public string unks
            {
                get
                {
                    string re = "";
                    foreach (char c in itemsWP.Keys)
                        re += c;
                    return re;
                }
            }
            public int power
            {
                get
                {
                    int re = 0;
                    foreach (char key in itemsWP.Keys)
                        re += itemsWP[key];
                    return re;
                }
            }
            public ItemEX(ItemEX itemEX)
            {
                qNum = itemEX.qNum;
                itemsWP = new Dictionary<char, int>(itemEX.itemsWP);
            }
            public ItemEX(string s)
            {
                int i = (s[0] == '-' ? 1 : 0);
                while (i < s.Length && !IsUnkNum(s[i])) i += 1;
                itemsWP = new Dictionary<char, int>();
                if (i == s.Length)
                {
                    qNum = new QNum(s);
                    return;
                }
                qNum = i == 0 ? QNum.One : new QNum(s.Substring(1, i));
                int l = i;
                char t = s[i++];
                itemsWP[t] = 0;
                while (i < s.Length)
                {
                    if (IsUnkNum(s[i]))
                    {
                        if (!itemsWP.ContainsKey(s[i])) itemsWP[s[i]] = 0;
                        if (l + 2 < i)
                        {
                            itemsWP[t] += MatchNum(s, l + 2);
                            l = i;
                            t = s[i];
                        }
                        else
                        {
                            itemsWP[t] += 1;
                            l = i;
                            t = s[i];
                        }
                    }
                    i += 1;
                }
                if (l + 2 < i)
                    itemsWP[t] += MatchNum(s, l + 2);
                else
                    itemsWP[t] += 1;
            }
            public ItemEX(Item item)
            {
                qNum = item.qNum;
                itemsWP = new Dictionary<char, int>();
                if (item.power != 0) itemsWP['x'] = item.power;
            }
            public ItemEX(QNum qNum)
            {
                this.qNum = qNum;
                itemsWP = new Dictionary<char, int>();
            }
            public ItemEX(int n)
            {
                qNum = new QNum(n);
                itemsWP = new Dictionary<char, int>();
            }
            public ItemEX(QNum qNum, Dictionary<char, int> itemsWP)
            {
                this.qNum = qNum;
                this.itemsWP = new Dictionary<char, int>(itemsWP);
            }
            public ItemEX(QNum qNum, char u, int power)
            {
                this.qNum = qNum;
                itemsWP = new Dictionary<char, int>
                {
                    [u] = power
                };
            }
            public bool IsFamily(ItemEX us)
            {
                if (itemsWP.Count != us.itemsWP.Count) return false;
                foreach (char x in itemsWP.Keys)
                    if (!(us.itemsWP.ContainsKey(x) && us.itemsWP[x] == itemsWP[x])) return false;
                return true;
            }
            public string ToString(bool first)
            {
                string r;
                r = power == 0 ? qNum.ToString(false) : qNum.ToString(true);
                if (first && r[0] == '+') r = r.Remove(0, 1);
                if (power == 0) return r;
                foreach (char key in itemsWP.Keys)
                    r += key + (itemsWP[key] == 1 ? "" : "^" + itemsWP[key].ToString());
                return r;
            }
            public override string ToString() => ToString(true);
            public QNum Compute(IDictionary<char, QNum> values)
            {
                QNum re = qNum;
                foreach (char x in itemsWP.Keys)
                    re *= values[x] ^ itemsWP[x];
                return re;
            }
            public HPAQNum Compute(IDictionary<char, HPAQNum> values)
            {
                HPAQNum re = new HPAQNum(qNum);
                foreach (char x in itemsWP.Keys)
                    re *= values[x] ^ itemsWP[x];
                return re;
            }
            public static ItemEX operator *(ItemEX a, ItemEX b)
            {
                ItemEX re = new ItemEX(a.qNum * b.qNum, a.itemsWP);
                foreach (char x in b.itemsWP.Keys)
                    if (re.itemsWP.ContainsKey(x)) re.itemsWP[x] += b.itemsWP[x];
                    else re.itemsWP[x] = b.itemsWP[x];
                return re;
            }
            public static ItemEX operator /(ItemEX a, ItemEX b)
            {
                ItemEX re = new ItemEX(a.qNum / a.qNum, a.itemsWP);
                foreach (char x in b.itemsWP.Keys)
                    if (re.itemsWP.ContainsKey(x)) re.itemsWP[x] -= b.itemsWP[x];
                    else re.itemsWP[x] = -b.itemsWP[x];
                return re;
            }
            public static ItemEX operator ^(ItemEX a, int b)
            {
                ItemEX re = new ItemEX(a.qNum ^ b, a.itemsWP);
                foreach (char x in re.itemsWP.Keys)
                    re.itemsWP[x] *= b;
                return re;
            }
            public static ItemEX operator *(ItemEX a, int b) => new ItemEX(a.qNum * b, a.itemsWP);
            public static ItemEX operator /(ItemEX a, int b) => new ItemEX(a.qNum / b, a.itemsWP);
            public static ItemEX operator *(ItemEX a, QNum b) => new ItemEX(a.qNum * b, a.itemsWP);
            public static ItemEX operator /(ItemEX a, QNum b) => new ItemEX(a.qNum / b, a.itemsWP);
            public Item ToItem()
            {
                if (itemsWP.Count > 1) throw new Exception("ItemEx ToItem failed");
                foreach (int i in itemsWP.Values) return new Item(qNum, i);
                throw new Exception("ItemEx ToItem failed");
            }
            public static bool operator ==(ItemEX a, ItemEX b)
            {
                if (a.qNum != b.qNum || a.itemsWP.Count != b.itemsWP.Count) return false;
                foreach (char x in a.itemsWP.Keys)
                {
                    if (!b.itemsWP.ContainsKey(x)) return false;
                    if (a.itemsWP[x] != b.itemsWP[x]) return false;
                }
                return true;
            }
            public static bool operator !=(ItemEX a, ItemEX b) => !(a == b);
        }
        /// <summary>
        /// 多项式结构
        /// </summary>
        public class Multinomial
        {
            public List<Item> items;
            public static readonly Multinomial Zero = new Multinomial(QNum.Zero);
            public static readonly Multinomial One = new Multinomial(QNum.One);
            public static readonly Multinomial Mine = new Multinomial(QNum.Mine);
            public Multinomial()
            {
                items = new List<Item>();
            }
            public Multinomial(List<Item> items)
            {
                this.items = items;
                Simpify();
            }
            public Multinomial(QNum n)
            {
                items = new List<Item>() { new Item(n) };
            }
            public Multinomial(Item n)
            {
                items = new List<Item>()
                {
                    n
                };
            }
            public Multinomial(int n)
            {
                items = new List<Item>()
                {
                    new Item(n)
                };
            }
            public Multinomial(Multinomial n)
            {
                items = new List<Item>(n.items);
            }
            public Multinomial(string s)
            {
                if (s[0] == '(' && s[s.Length - 1] == ')') s = s.Substring(1, s.Length - 2);
                items = new List<Item>();
                int i, l = 0;
                for (i = 1; i < s.Length; i++)
                {
                    if (s[i] == '-' || s[i] == '+')
                    {
                        items.Add(new Item(s.Substring(l, i - l)));
                        l = i;
                    }
                }
                items.Add(new Item(s.Substring(l, i - l)));
                Simpify();
            }
            public Multinomial(IList<int> IDs)
            {
                items = new List<Item>();
                for (int i = 0; i < IDs.Count; i++)
                    if (IDs[i] != 0)
                        items.Add(new Item(new QNum(IDs[i]), IDs.Count - i - 1));
                if (items.Count == 0) items.Add(Item.Zero);
            }
            public Multinomial(IList<QNum> IDs)
            {
                items = new List<Item>();
                for (int i = 0; i < IDs.Count; i++)
                    if (IDs[i] != 0)
                        items.Add(new Item(IDs[i], IDs.Count - i - 1));
                if (items.Count == 0) items.Add(Item.Zero);
            }
            /// <summary>
            /// 拉格朗日插值法
            /// </summary>
            /// <param name="points"></param>
            public static Multinomial Lagrange(IList<PointS> points)
            {
                QNum temp;
                Multinomial temp2, re = Zero;
                List<QNum> ids = new List<QNum>(2)
                {
                    QNum.One,
                    QNum.Zero
                };
                for (int i = 0; i < points.Count; i++)
                {
                    temp = QNum.One;
                    temp2 = One;
                    for (int j = 0; j < points.Count; j++)
                    {
                        if (j != i)
                        {
                            temp *= points[i].x - points[j].x;
                            ids[1] = points[j].x * -1;
                            temp2 *= new Multinomial(ids);
                        }
                    }
                    re += temp2 * (points[i].y / temp);
                }
                re.Simpify();
                return re;
            }
            public QNum Compute(QNum x)
            {
                QNum result = QNum.Zero;
                foreach (Item item in items)
                    result += item.Compute(x);
                return result;
            }
            public HPA Compute(HPA x)
            {
                HPA result = new HPA(HPA.Zero);
                foreach (Item item in items)
                    result += item.Compute(x);
                return result;
            }
            public HPAQNum Compute(HPAQNum x)
            {
                HPAQNum result = new HPAQNum(HPAQNum.Zero);
                foreach (Item item in items)
                    result += item.Compute(x);
                return result;
            }
            public Multinomial Compute(Multinomial x)
            {
                Multinomial re = Zero;
                foreach (Item item in items)
                    re += (x ^ item.power) * item.qNum;
                return re;
            }
            public override string ToString()
            {
                return ToString(true);
            }
            public string ToString(bool first)
            {
                string r = "";
                foreach (Item item in items)
                    if (first)
                    {
                        r += item.ToString(true);
                        first = false;
                    }
                    else r += item.ToString(false);

                return r;
            }
            public void Simpify()
            {
                int i = 0, j = 0;
                while (i < items.Count)
                {
                    if (items[i].qNum == QNum.Zero)
                    {
                        if (items.Count > 1)
                        {
                            items.Remove(items[i]);
                            continue;
                        }
                        else
                        {
                            items.Remove(items[i]);
                            items.Add(Item.Zero);
                            break;
                        }
                    }
                    j = i + 1;
                    while (j < items.Count)
                    {
                        if (items[i].power == items[j].power)
                        {
                            items[i] = items[i] + items[j];
                            items.Remove(items[j]);
                            if (items[i].qNum == QNum.Zero)
                            {
                                items.Remove(items[i]);
                                i -= 1;
                                break;
                            }
                        }
                        else j += 1;
                    }
                    i += 1;
                }
                if (items.Count == 0) items.Add(Item.Zero);
                else items.Sort((Item a, Item b) => b.power - a.power);
                return;
            }
            /// <summary>
            /// 系数转化为IntList
            /// </summary>
            /// <returns></returns>
            public List<int> ToIntList()
            {
                List<int> re = new List<int>(items[0].power + 1);
                foreach (Item i in items)
                {
                    while (i.power < items[0].power - re.Count) re.Add(0);
                    re.Add((int)i.qNum.Value);
                }

                return re;
            }
            public void AddItem(Item item, bool simplify = true)
            {
                this.items.Add(item);
                if (simplify) Simpify();
            }
            /// <summary>
            /// 求导
            /// </summary>
            /// <returns></returns>
            public Multinomial DxyF()
            {
                Multinomial re = new Multinomial();
                foreach (Item item in items)
                    if (item.power != 0)
                        re.AddItem(new Item(item.qNum * item.power, item.power - 1), false);
                if (re.items.Count == 0) re.items.Add(Item.Zero);
                return re;
            }
            /// <summary>
            /// 积分
            /// </summary>
            /// <returns></returns>
            public Multinomial AntiDxyF()
            {
                Multinomial re = new Multinomial();
                foreach (Item item in items)
                    if (item.power != -1)
                        re.AddItem(new Item(item.qNum / (item.power + 1), item.power + 1), false);
                return re;
            }
            public Multinomial ItemsInted(ref int q)
            {
                q = Nqisit(items);
                return this * new Item(q);
            }
            public Multinomial ItemsInted() => this * new Item(Nqisit(items));
            public List<QNum> Solve(QNum left, QNum right, QNum step, QNum f)
            {
                Multinomial m;
                if (f == QNum.Zero) m = this;
                else m = this - new Multinomial(f);
                int t = (int)(((right - left) / step).Value);
                List<QNum> re = new List<QNum>();
                bool? pos = null;
                QNum temp;
                while (t >= 0)
                {
                    temp = m.Compute(left);
                    if (temp == QNum.Zero)
                    {
                        re.Add(left);
                        pos = null;
                    }
                    else if (pos == null) pos = temp > QNum.Zero;
                    else if (pos != temp > QNum.Zero)
                    {
                        pos = temp > QNum.Zero;
                        re.Add(left - (step / 2));
                    }
                    left += step;
                    t -= 1;
                }
                return re;
            }
            public List<QNum> Solve(QNum left, QNum right, QNum step) => Solve(left, right, step, QNum.Zero);
            public List<QNum> Solve()
            {
                if (items[0].power == 0) return new List<QNum>();
                if (items[0].power == 1) return new List<QNum>() { items.Count > 1 ? items[1].qNum / items[0].qNum * -1 : QNum.Zero };
                if (items[0].power == 2)
                {
                    if (items.Count == 1) return new List<QNum>() { QNum.Zero };
                    if (items.Count == 2)
                    {
                        if (items[1].power == 0)
                        {
                            List<QNum> re = new List<QNum>();
                            if (items[0].qNum.Up * items[1].qNum.Up < 0)
                            {
                                re.Add(new QNum(Math.Sqrt((items[1].qNum / items[0].qNum * -1).Value)));
                                re.Add(new QNum(-Math.Sqrt((items[1].qNum / items[0].qNum * -1).Value)));
                            }
                            return re;
                        }
                        else
                        {
                            return new List<QNum>() { QNum.Zero, items[1].qNum / items[0].qNum * -1 };
                        }
                    }
                    else
                    {
                        List<QNum> re = new List<QNum>();
                        QNum detla = (items[1].qNum ^ 2) - (items[0].qNum * items[2].qNum * 4);
                        if (detla < QNum.Zero) return re;
                        if (detla == 0)
                        {
                            re.Add((items[1].qNum * -1) / (items[0].qNum * 2));
                            return re;
                        }
                        else
                        {
                            re.Add(((items[1].qNum * -1) + new QNum(Math.Sqrt(detla.Value))) / (items[0].qNum * 2));
                            re.Add(((items[1].qNum * -1) + new QNum(-Math.Sqrt(detla.Value))) / (items[0].qNum * 2));
                            return re;
                        }
                    }
                }
                return Solve(new QNum(-20), new QNum(20), new QNum(0.2));
            }
            /// <summary>
            /// 因式分解
            /// </summary>
            /// <returns></returns>
            public List<Multinomial> Factorization()
            {
                List<Multinomial> re = new List<Multinomial>();
                List<int> fs, ls, ids;
                int q = 1, i, maxi, l;
                bool ok;
                Multinomial temp = this.ItemsInted(ref q), temp2;
                if (q != 1) re.Add(new Multinomial(new QNum(q)));
                while (temp.items[0].power > 1)
                {
                    fs = AllFactorWT((int)temp.items[0].qNum.Value, true);
                    ls = AllFactorWT((int)temp.items[temp.items.Count - 1].qNum.Value);
                    maxi = Math.Abs((int)temp.items[1].qNum.Value);
                    for (i = 2; i < temp.items.Count - 1; i++)
                    {
                        q = Math.Abs((int)temp.items[i].qNum.Value);
                        if (maxi < q) maxi = q;
                    }
                    ok = false;
                    for (q = 1; q < temp.items[0].power; q++)
                    {
                        foreach (int fq in fs)
                        {
                            foreach (int lq in ls)
                            {
                                ids = new List<int> { fq };
                                for (i = 1; i < q; i++)
                                    ids.Add(maxi);
                                ids.Add(lq);
                                l = (int)Math.Pow(maxi * 2 + 1, q + 1);
                                for (i = 0; i <= l; i++)
                                {
                                    temp2 = new Multinomial(ids);
                                    if (temp2.items[0].qNum == 0) continue;
                                    MuliModQ md = temp / temp2;
                                    if (md.mod == 0)
                                    {
                                        re.Add(temp2);
                                        temp = md.quotient;
                                        temp.Simpify();
                                        ok = true;
                                        break;
                                    }
                                    if (ids.Count <= 2) break;
                                    ListYeild(ids, -maxi, maxi, 1, 1, -1);
                                }
                                if (ok)
                                    break;
                            }
                            if (ok) break;
                        }
                        if (ok) break;
                    }
                    if (!ok) break;
                }
                if (temp != 1) re.Add(temp);
                re.Sort((Multinomial a, Multinomial b) => a.items[0].power - b.items[0].power);
                return re;
            }
            /// <summary>
            /// 计算所有多项式相乘的值
            /// </summary>
            /// <param name="multinomials"></param>
            /// <returns></returns>
            public static Multinomial MultinomialsMulti(IList<Multinomial> multinomials)
            {
                Multinomial re = new Multinomial(One);
                foreach (Multinomial i in multinomials)
                    re *= i;
                re.Simpify();
                return re;
            }
            public static string MultionalsListString(IList<Multinomial> multinomials)
            {
                string re = "";
                foreach (Multinomial i in multinomials)
                    re += "(" + i.ToString() + ")";
                return re;
            }

            public static bool operator ==(Multinomial a, Multinomial b)
            {
                if (a.items.Count != b.items.Count) return false;
                for (int i = 0; i < a.items.Count; i++)
                    if (a.items[i] != b.items[i]) return false;
                return true;
            }
            public static bool operator !=(Multinomial a, Multinomial b) => !(a == b);
            /// <summary>
            /// UnSimpified
            /// </summary>
            /// <param name="a"></param>
            /// <param name="b"></param>
            /// <returns></returns>
            public static Multinomial operator +(Multinomial a, Multinomial b)
            {
                Multinomial result = new Multinomial(a);
                result.items.AddRange(b.items);
                return result;
            }
            /// <summary>
            /// UnSimpified
            /// </summary>
            /// <param name="a"></param>
            /// <param name="b"></param>
            /// <returns></returns>
            public static Multinomial operator -(Multinomial a, Multinomial b)
            {
                Multinomial result = new Multinomial(a);
                foreach (Item i in b.items)
                    result.AddItem(i * QNum.Mine, false);
                return result;
            }
            public static Multinomial operator *(Multinomial a, Item b)
            {
                Multinomial result = new Multinomial(a);
                for (int i = 0; i < result.items.Count; i++)
                    result.items[i] *= b;
                return result;
            }
            public static Multinomial operator /(Multinomial a, Item b)
            {
                Multinomial result = new Multinomial(a);
                for (int i = 0; i < result.items.Count; i++)
                    result.items[i] /= b;
                return result;
            }
            public static Multinomial operator *(Multinomial a, QNum b)
            {
                Multinomial result = new Multinomial(a);
                for (int i = 0; i < result.items.Count; i++)
                    result.items[i] *= b;
                return result;
            }
            public static Multinomial operator /(Multinomial a, QNum b)
            {
                Multinomial result = new Multinomial(a);
                for (int i = 0; i < result.items.Count; i++)
                    result.items[i] /= b;
                return result;
            }
            public static Multinomial operator *(Multinomial a, Multinomial b)
            {
                Multinomial result = Zero;
                for (int i = 0; i < a.items.Count; i++)
                    result += b * a.items[i];
                result.Simpify();
                return result;
            }
            public static Multinomial operator +(Multinomial a, QNum b)
            {
                Multinomial re = new Multinomial(a);
                re.items.Add(new Item(b));
                return re;
            }
            public static Multinomial operator -(Multinomial a, QNum b)
            {
                Multinomial re = new Multinomial(a);
                re.items.Add(new Item(b * QNum.Mine));
                return re;
            }
            /// <summary>
            /// UnSimpified
            /// </summary>
            /// <param name="a"></param>
            /// <param name="b"></param>
            /// <returns></returns>
            public static MuliModQ operator /(Multinomial a, Multinomial b)
            {
                Multinomial result = new Multinomial(a);
                Multinomial result2 = new Multinomial();
                while (result.items[0].power >= b.items[0].power)
                {
                    Item q = result.items[0] / b.items[0];
                    result -= b * q;
                    result2.items.Add(q);
                    result.Simpify();
                    if (result == 0) break;
                }
                return new MuliModQ(b, result2, result);
            }
            public static Multinomial operator ^(Multinomial a, int b)
            {
                if (b == 0) return Zero;
                Multinomial re = new Multinomial(a);
                while (b-- > 1) re *= a;
                return re;
            }
            public static bool operator ==(Multinomial a, int b) => a.items.Count == 1 && a.items[0].power == 0 && a.items[0].qNum == b;
            public static bool operator !=(Multinomial a, int b) => a.items.Count != 1 || a.items[0].power != 0 || a.items[0].qNum != b;
        }
        /// <summary>
        /// 快速多项式
        /// </summary>
        public class FMT
        {
            public Dictionary<int, QNum> Items;
            public FMT(int power, QNum para)
            {
                Items = new Dictionary<int, QNum>() { [power] = para };
            }
            public FMT(Dictionary<int, QNum> items)
            {
                Items = items;
            }
            public FMT(Multinomial multinomial)
            {
                Items = new Dictionary<int, QNum>();
                foreach(Item i in multinomial.items)
                {
                    if (Items.ContainsKey(i.power)) Items[i.power] += i.qNum;
                    else Items[i.power] = i.qNum;
                }
            }
            public FMT()
            {
                Items = new Dictionary<int, QNum>();
            }
            public FMT(FMT fMT)
            {
                Items = new Dictionary<int, QNum>(fMT.Items);
            }
            public Multinomial GetMultinomial()
            {
                Multinomial r = new Multinomial();
                List<int> t = new List<int>(Items.Keys);
                t.Sort((a, b) => (b - a));
                foreach (int k in t)
                {
                    r.items.Add(new Item(Items[k], k));
                }
                return r;
            }
            public void Simpify()
            {
                List<int> rf = new List<int>(Items.Keys);
                foreach(int k in rf)
                {
                    if (Items[k] == 0) Items.Remove(k);
                }
            }
            public static FMT operator +(FMT a, FMT b)
            {
                FMT r = new FMT(b);
                foreach(int k in a.Items.Keys)
                {
                    if (r.Items.ContainsKey(k)) r.Items[k] += a.Items[k];
                    else r.Items[k] = a.Items[k];
                }
                r.Simpify();
                return r;
            }
            public static FMT operator -(FMT a, FMT b)
            {
                FMT r = new FMT(b);
                foreach (int k in a.Items.Keys)
                {
                    if (r.Items.ContainsKey(k)) r.Items[k] -= a.Items[k];
                    else r.Items[k] = a.Items[k].GetMine();
                }
                r.Simpify();
                return r;
            }
            public static FMT operator *(FMT a, FMT b)
            {
                FMT r = new FMT();
                foreach (int k in a.Items.Keys)
                {
                    foreach(int j in b.Items.Keys)
                    {
                        int l = k + j;
                        if (r.Items.ContainsKey(l)) r.Items[l] += a.Items[k] * b.Items[j];
                        else r.Items[l] = a.Items[k] * b.Items[j];
                    }
                }
                r.Simpify();
                return r;
            }
            public static FMT operator ^(FMT an, int bn)
            {
                if (bn < 0) throw new Exception("FMT ^ power<0");
                FMT re = an;
                FMT temp2 = new FMT(0,QNum.One);
                while (bn > 1)
                {
                    if (bn % 2 == 0)
                    {
                        re *= re;
                        bn /= 2;
                    }
                    else
                    {
                        temp2 *= re;
                        bn -= 1;
                    }
                }
                return re * temp2;
            }
            public override string ToString()
            {
                return GetMultinomial().ToString();
            }
        }
        /// <summary>
        /// 多系数多项式
        /// </summary>
        public class MultinomialEX
        {
            public static readonly MultinomialEX One = new MultinomialEX(1);
            public static readonly MultinomialEX Zero = new MultinomialEX(0);
            public static readonly MultinomialEX Mine = new MultinomialEX(-1);
            public List<ItemEX> items;
            public List<char> UnNs
            {
                get
                {
                    List<char> re = new List<char>();
                    foreach (ItemEX x in items)
                        foreach (char c in x.itemsWP.Keys)
                            if (!re.Contains(c)) re.Add(c);
                    return re;
                }
            }
            public MultinomialEX()
            {

            }
            public MultinomialEX(string s)
            {
                if (s[0] == '(' && s[s.Length - 1] == ')') s = s.Substring(1, s.Length - 2);
                items = new List<ItemEX>();
                int i, l = 0;
                for (i = 1; i < s.Length; i++)
                {
                    if (s[i] == '-' || s[i] == '+')
                    {
                        items.Add(new ItemEX(s.Substring(l, i - l)));
                        l = i;
                    }
                }
                items.Add(new ItemEX(s.Substring(l, i - l)));
                Simpify();
            }
            public MultinomialEX(List<ItemEX> items)
            {
                this.items = items;
            }
            public MultinomialEX(int n)
            {
                items = new List<ItemEX>() { new ItemEX(n) };
            }
            public MultinomialEX(QNum qNum)
            {
                items = new List<ItemEX>() { new ItemEX(qNum) };
            }
            public MultinomialEX(Item item)
            {
                items = new List<ItemEX>() { new ItemEX(item) };
            }
            public MultinomialEX(ItemEX item)
            {
                items = new List<ItemEX>() { new ItemEX(item) };
            }
            public MultinomialEX(MultinomialEX multinomialEX)
            {
                items = new List<ItemEX>(multinomialEX.items);
            }
            public MultinomialEX(Multinomial multinomial)
            {
                items = new List<ItemEX>();
                foreach (Item x in multinomial.items)
                    items.Add(new ItemEX(x));
            }
            public void Simpify()
            {
                int i = 0, j = 0;
                while (i < items.Count)
                {
                    if (items[i].qNum == QNum.Zero)
                    {
                        if (items.Count > 1)
                        {
                            items.Remove(items[i]);
                            continue;
                        }
                        else
                        {
                            items.Remove(items[i]);
                            items.Add(new ItemEX(ItemEX.Zero));
                            break;
                        }
                    }
                    j = i + 1;
                    while (j < items.Count)
                    {
                        if (items[i] == items[j])
                        {
                            items[i].qNum += items[j].qNum;
                            items.Remove(items[j]);
                            if (items[i].qNum == QNum.Zero)
                            {
                                items.Remove(items[i]);
                                i -= 1;
                                break;
                            }
                        }
                        else j += 1;
                    }
                    i += 1;
                }
                items.Sort((ItemEX a, ItemEX b) => b.power - a.power);
                return;
            }
            public void SimpifyToInt()
            {
                int q = Nqisit(items);
                foreach (ItemEX x in items)
                    x.qNum *= q;
            }
            public QNum Compute(Dictionary<char, QNum> values)
            {
                QNum re = QNum.Zero;
                foreach (ItemEX x in items)
                    re += x.Compute(values);
                return re;
            }
            public HPAQNum Compute(Dictionary<char, HPAQNum> values)
            {
                HPAQNum re = new HPAQNum(HPAQNum.Zero);
                foreach (ItemEX x in items)
                    re += x.Compute(values);
                return re;
            }
            /// <summary>
            /// UnSimpled
            /// </summary>
            /// <param name="a"></param>
            /// <param name="b"></param>
            /// <returns></returns>
            public static MultinomialEX operator +(MultinomialEX a, MultinomialEX b)
            {
                MultinomialEX re = new MultinomialEX(a);
                re.items.AddRange(b.items);
                return re;
            }
            /// <summary>
            /// UnSimpled
            /// </summary>
            /// <param name="a"></param>
            /// <param name="b"></param>
            /// <returns></returns>
            public static MultinomialEX operator -(MultinomialEX a, MultinomialEX b)
            {
                MultinomialEX re = new MultinomialEX(a);
                foreach (ItemEX x in b.items)
                    re.items.Add(x * -1);
                return re;
            }
            public static MultinomialEX operator *(MultinomialEX a, ItemEX b)
            {
                MultinomialEX re = new MultinomialEX(a);
                for (int i = 0; i < re.items.Count; i++)
                    re.items[i] *= b;
                return re;
            }
            public static MultinomialEX operator /(MultinomialEX a, ItemEX b)
            {
                MultinomialEX re = new MultinomialEX(a);
                for (int i = 0; i < re.items.Count; i++)
                    re.items[i] /= b;
                return re;
            }
            public static MultinomialEX operator *(MultinomialEX a, MultinomialEX b)
            {
                MultinomialEX result = new MultinomialEX(Zero);
                for (int i = 0; i < a.items.Count; i++)
                    result += b * a.items[i];
                result.Simpify();
                return result;
            }
            public override string ToString()
            {
                return ToString(true);
            }
            public string ToString(bool first)
            {
                string r = "";
                foreach (ItemEX item in items)
                    if (first)
                    {
                        r += item.ToString(true);
                        first = false;
                    }
                    else r += item.ToString(false);
                return r;
            }
            public Multinomial ToMultinoal()
            {
                Multinomial re = new Multinomial();
                foreach (ItemEX x in items)
                    re.items.Add(x.ToItem());
                return re;
            }
        }
        /// <summary>
        /// 高级Point
        /// </summary>
        public struct PointS
        {
            public QNum x;
            public QNum y;
            public static PointS Null = new PointS(QNum.Null, QNum.Null);
            public double Length { get => Math.Sqrt(((x ^ 2) + (y ^ 2)).Value); }
            public double Angle { get => Math.Atan2(y.Value, x.Value); }
            public PointS(QNum x, QNum y)
            {
                this.x = x;
                this.y = y;
            }
            public PointS(int x, int y)
            {
                this.x = new QNum(x);
                this.y = new QNum(y);
            }
            public PointS(double angle, double length)
            {
                x = new QNum(length * Math.Cos(angle));
                y = new QNum(length * Math.Sin(angle));
            }
            public PointS(string s)//(a,b) a,b a b
            {
                if (s[0] == '(') s = s.Substring(1);
                if (s[s.Length - 1] == ')') s = s.Substring(0, s.Length - 1);
                int i = s.IndexOf(',');
                if (i == -1) i = s.IndexOf(' ');
                x = new QNum(s.Substring(0, i));
                y = new QNum(s.Substring(i + 1, s.Length - i - 1));
            }
            public string ToString(bool IsRect)
            {
                if (IsRect) return "(" + x.ToString() + "," + y.ToString() + ")";
                else return "(" + Angle.ToString() + "," + Length.ToString() + ")";
            }
            public static PointS operator +(PointS a, PointS b) => new PointS(a.x + b.x, a.y + b.y);
            public static PointS operator -(PointS a, PointS b) => new PointS(a.x - b.x, a.y - b.y);
            public static PointS operator *(PointS a, QNum b) => new PointS(a.x * b, a.y * b);
            public static PointS operator /(PointS a, QNum b) => new PointS(a.x / b, a.y / b);
            public static bool operator ==(PointS a, PointS b) => a.x == b.x && a.y == b.y;
            public static bool operator !=(PointS a, PointS b) => !(a == b);
            public override string ToString() => ToString(true);
        }
        /// <summary>
        /// 多项式除法返回结构
        /// </summary>
        public class MuliModQ
        {
            public Multinomial mod;
            public Multinomial quotient;
            public Multinomial divisor;
            public MuliModQ(Multinomial divisor, Multinomial quotient, Multinomial mod)
            {
                this.quotient = quotient;
                this.mod = mod;
                this.divisor = divisor;
            }
            public override string ToString() => "(" + divisor.ToString() + ")(" + quotient.ToString() + ")" + (mod == 0 ? "" : mod.ToString(false));
        }
        /// <summary>
        /// 正整数幂结构
        /// </summary>
        public class NNumDivis
        {
            public int Num;
            public int Power;

            public NNumDivis(int num, int power)
            {
                this.Num = num;
                this.Power = power;
            }
            public double Value
            {
                get
                {
                    return Math.Pow((double)Num, (double)Power);
                }
            }
            public override string ToString() => Num == 0 ? "0" : (Num.ToString() + (Power == 1 ? "" : "^" + Power.ToString()));
            public static int FindPower(int n, IList<NNumDivis> ls)
            {
                foreach (NNumDivis w in ls)
                    if (w.Num == n) return w.Power;
                return -1;
            }
        }
        /// <summary>
        /// 高精度算法类
        /// </summary>
        public class HPA
        {
            public IList<byte> Digitals;
            public bool pos;
            public static readonly HPA One = new HPA("1");
            public static readonly HPA Zero = new HPA("0");
            public static readonly HPA Mine = new HPA("1", false);
            public static readonly HPA Two = new HPA("2");
            public string Num
            {
                get
                {
                    string re = pos ? "" : "-";
                    for (int i = Len - 1; i >= 0; i--)
                        re += (char)(Digitals[i] + '0');
                    return re;
                }
            }
            public int Len { get => Digitals.Count; }
            public override string ToString() => Num;
            public HPA(IList<byte> Num, bool IsOped = false, bool pos = true, bool onlyClass = false)
            {
                if (onlyClass) Digitals = Num;
                else Digitals = new List<byte>(Num);
                this.pos = pos;
                if (!IsOped)
                    OpstList(Digitals);
            }
            public HPA(string num, bool? pos = null)
            {
                int i = num[0] == '-' ? 1 : 0;
                if (pos == null)
                    this.pos = i == 0;
                else this.pos = (bool)pos;
                Digitals = new List<byte>();
                for (int j = num.Length - 1; j >= i; j--)
                    Digitals.Add((byte)(num[j] - '0'));
            }
            public HPA(HPA hPA)
            {
                pos = hPA.pos;
                Digitals = new List<byte>(hPA.Digitals);
            }
            public HPA(HPA hPA, bool pos,bool onlyclass=false)
            {
                this.pos = pos;
                if (onlyclass) Digitals = hPA.Digitals;
                else Digitals = new List<byte>(hPA.Digitals);
            }
            public HPA(int n)
            {
                string s = n.ToString();
                Digitals = new List<byte>();
                for (int i = s.Length - 1; i > 0; i--)
                    Digitals.Add((byte)(s[i] - '0'));
                if (s[0] != '-') Digitals.Add((byte)(s[0] - '0'));
                pos = n >= 0;
            }
            public static string DiviVal(HPA a, HPA b, int DotLen)
            {
                if (a == Zero) return "0";
                if (DotLen <= 0) return (a / b).Num;
                HPA at = new HPA(a);
                DotLen += b.Len - at.Len;
                for (int i = 0; i < DotLen; i++)
                    at.Digitals.Insert(0, 0);
                at /= b;
                while (at.Digitals[0] == '0') at.Digitals.RemoveAt(0);
                DotLen = at.Len - DotLen - 1;
                if (DotLen > 0 && at.Len < DotLen + 1) return at.Num;
                string dot = "";
                while (DotLen < 0)
                {
                    dot += "0";
                    DotLen++;
                }
                return (dot + at.Num).Insert(DotLen + 1, ".");
            }
            public int ToInt() => Convert.ToInt32(Num);
            public static bool operator ==(HPA a, HPA b) => a.Len == b.Len && a.pos == b.pos && IsEqualList(a.Digitals, b.Digitals, a.Len);
            public static bool operator !=(HPA a, HPA b) => !(a == b);
            public static bool operator >=(HPA a, HPA b) => !(a < b);
            public static bool operator <=(HPA a, HPA b) => !(a > b);
            public static bool operator >(HPA a, HPA b)
            {
                if (a == b) return false;
                if (a.pos == false && b.pos == true) return false;
                if (a.pos == true && b.pos == false) return true;
                if (a.pos && b.pos)
                {
                    if (a.Len > b.Len) return true;
                    if (a.Len < b.Len) return false;
                    for (int i = a.Len - 1; i >= 0; i--)
                        if (a.Digitals[i] > b.Digitals[i]) return true;
                        else if (a.Digitals[i] < b.Digitals[i]) return false;
                }
                else
                {
                    if (a.Len > b.Len) return false;
                    if (a.Len < b.Len) return true;
                    for (int i = a.Len - 1; i >= 0; i--)
                        if (a.Digitals[i] > b.Digitals[i]) return false;
                        else if (a.Digitals[i] < b.Digitals[i]) return true;
                }
                return false;
            }
            public static bool operator <(HPA a, HPA b) => !(a > b || a == b);
            public static HPA operator +(HPA an, HPA bn)
            {
                if (an.pos == bn.pos)
                {

                    IList<byte> a, b;
                    if (an.pos && an < bn || !an.pos && an > bn)
                    {
                        a = new List<byte>(bn.Digitals);
                        b = an.Digitals;
                    }
                    else
                    {
                        a = new List<byte>(an.Digitals);
                        b = bn.Digitals;
                    }
                    byte temp = 0, c;
                    int i, al = a.Count, bl = b.Count;
                    for (i = 0; i < bl; i++)
                    {
                        c = (byte)(a[i] + b[i] + temp);
                        if (c > 9)
                        {
                            temp = 1;
                            c -= 10;
                        }
                        else temp = 0;
                        a[i] = c;
                    }
                    while (temp > 0)
                    {
                        if (i >= al)
                        {
                            a.Add(1);
                            break;
                        }
                        if (a[i] == 9) a[i++] = 0;
                        else
                        {
                            a[i] += 1;
                            break;
                        }
                    }
                    return new HPA(a, true, an.pos, true);
                }
                else
                {
                    if (an.pos) return an - (new HPA(bn.Digitals, true));
                    else return bn - (new HPA(an.Digitals, true));
                }
            }
            public static HPA operator -(HPA an, HPA bn)
            {
                if (an == bn) return new HPA(new List<byte>() { 0 }, true, true, true);
                if (an.pos == bn.pos)
                {
                    bool pos;
                    IList<byte> a, b;
                    if (an.pos && an < bn || !an.pos && an > bn)
                    {
                        a = new List<byte>(bn.Digitals);
                        b = an.Digitals;
                        pos = false;
                    }
                    else
                    {
                        a = new List<byte>(an.Digitals);
                        b = bn.Digitals;
                        pos = true;
                    }
                    byte temp = 0;
                    short c;
                    int i, bl = b.Count, al = a.Count;
                    for (i = 0; i < bl; i++)
                    {
                        if (b[i] == 0 && temp == 0) continue;
                        c = (short)(a[i] - b[i] - temp);
                        if (c < 0)
                        {
                            c += 10;
                            temp = 1;
                        }
                        else temp = 0;
                        a[i] = (byte)c;
                    }
                    while (temp > 0)
                    {
                        if (a[i] == 0) a[i++] = 9;
                        else
                        {
                            if (i == al - 1 && a[i] == 1) a.RemoveAt(i);
                            else a[i] -= 1;
                            break;
                        }
                    }
                    while (a[a.Count - 1] == 0) a.RemoveAt(a.Count - 1);
                    return new HPA(a, true, pos, true);
                }
                else
                {
                    if (an.pos) return an + (new HPA(bn.Digitals, true, true));
                    else return an + (new HPA(bn.Digitals, true, false));
                }
            }
            public static HPA operator *(HPA an, HPA bn)
            {
                if (an == Zero || bn == Zero) return new HPA(Zero);
                if (an == One) return new HPA(bn, an.pos == bn.pos);
                if (bn == One) return new HPA(an, an.pos == bn.pos);
                int ai = 0, bi = 0, n;
                byte c, temp = 0;
                IList<byte> re = new List<byte>();
                while (ai < an.Len)
                {
                    if (an.Digitals[ai] == 0) { ai += 1; continue; }
                    n = ai;
                    while (bi < bn.Len)
                    {
                        if (re.Count > n)
                        {
                            c = (byte)(an.Digitals[ai] * bn.Digitals[bi] + re[n] + temp);
                            if (c > 9)
                            {
                                temp = (byte)(c / 10);
                                c %= 10;
                            }
                            else temp = 0;
                            re[n] = c;
                        }
                        else
                        {
                            c = (byte)(an.Digitals[ai] * bn.Digitals[bi] + temp);
                            if (c > 9)
                            {
                                temp = (byte)(c / 10);
                                c %= 10;
                            }
                            else temp = 0;
                            while (re.Count < n) re.Add(0);
                            re.Add(c);
                        }
                        bi += 1;
                        n += 1;
                    }
                    while (temp > 0)
                    {
                        n += 1;
                        if (re.Count > n)
                        {
                            c = (byte)(re[n] + temp);
                            re[n] = (byte)(c % 10);
                            temp = (byte)(c / 10);
                        }
                        else
                        {
                            re.Add((byte)(temp % 10));
                            temp = (byte)(temp / 10);
                        }
                    }
                    ai += 1;
                    bi = 0;
                }
                while (re[re.Count - 1] == 0) re.RemoveAt(re.Count - 1);
                return new HPA(re, true, an.pos == bn.pos, true);
            }
            public static HPA operator *(HPA an, int bn)
            {
                if (bn == 1) return new HPA(an);
                if (bn == 0) return new HPA(an);
                if (bn == -1) return new HPA(an.Digitals, true, !an.pos);
                return an * new HPA(bn);
            }
            public static HPA operator ^(HPA an, int bn)
            {
                if (bn < 0) throw new Exception("HPA ^ power<0");
                HPA re = an;
                HPA temp2 = One;
                while (bn > 1)
                {
                    if (bn % 2 == 0)
                    {
                        re *= re;
                        bn /= 2;
                    }
                    else
                    {
                        temp2 *= re;
                        bn -= 1;
                    }
                }
                return re * temp2;
            }
            public static HPA operator ^(HPA an, HPA bn)
            {
                if (!bn.pos) throw new Exception("HPA ^ power<0");
                HPA re = an;
                HPA temp2 = One;
                while (bn > One)
                {
                    if (bn.Digitals[0] % 2 == 0)
                    {
                        re *= re;
                        bn /= Two;
                    }
                    else
                    {
                        temp2 *= re;
                        bn -= One;
                    }
                    //Console.WriteLine(temp.Num);
                }

                return re * temp2;
            }
            public static HPA operator /(HPA an, HPA bn)
            {

                HPA temp = new HPA(bn);
                HPA re = new HPA(an);
                temp.pos = re.pos = true;
                if (re < temp) return new HPA(Zero);
                List<byte> rc = new List<byte>();
                int i = an.Len - bn.Len - (an.Digitals[an.Len - 1] >= bn.Digitals[bn.Len - 1] ? 0 : 1), q;
                for (q = 0; q < i; q++)
                    temp.Digitals.Insert(0, 0);
                while (temp.Len >= bn.Len)
                {
                    if (re.Len < temp.Len)
                    {
                        if (rc.Count != 0) rc.Add(0);
                        temp.Digitals.RemoveAt(0);
                        continue;
                    }
                    if (temp.Len > 1 && re.Len > 1)
                    {
                        if (re.Len == temp.Len) q = (re.Digitals[re.Len - 1] * 10 + re.Digitals[re.Len - 2]) / (temp.Digitals[temp.Len - 1] * 10 + temp.Digitals[temp.Len - 2]) - 1;
                        else if (re.Len > 2) q = (re.Digitals[re.Len - 1] * 100 + re.Digitals[re.Len - 2] * 10 + re.Digitals[re.Len - 3]) / (temp.Digitals[temp.Len - 1] * 10 + temp.Digitals[temp.Len - 2]) - 1;
                        else q = 0;
                        if (q > 0)
                        {
                            re -= temp * q;
                            while (!re.pos)
                            {
                                q -= 1;
                                re += temp;
                            }
                        }
                        else q = 0;
                    }
                    else q = 0;
                    if (!re.pos) throw new Exception();
                    while (!(re < temp))
                    {
                        re -= temp;
                        q += 1;
                    }
                    temp.Digitals.RemoveAt(0);
                    rc.Add((byte)q);
                }
                while (rc[0] == 0) rc.RemoveAt(0);
                return new HPA(rc, false, an.pos == bn.pos, true);
            }
            public static HPA operator /(HPA an, int bn)
            {
                if (bn == 1) return new HPA(an);
                if (bn == -1) return new HPA(an, !an.pos);
                return an / new HPA(bn);
            }
            public static HPA operator %(HPA an, HPA bn)
            {
                if (bn.Len == 1)
                {
                    if (bn.Digitals[0] == 1) return new HPA(Zero);
                    if (bn.Digitals[0] == 2) return new HPA(new List<byte> { (byte)(an.Digitals[0] % 2) }, true, an.pos == bn.pos, true);
                    if (bn.Digitals[0] == 4 && an.Len > 2) return new HPA(new List<byte> { (byte)((an.Digitals[1] * 10 + an.Digitals[0]) % 4) }, true, an.pos == bn.pos, true);
                    if (bn.Digitals[0] == 5) return new HPA(new List<byte> { (byte)(an.Digitals[0] % 5) }, true, an.pos == bn.pos, true);
                    if (an.Len == 1) return new HPA(new List<byte> { (byte)(an.Digitals[0] % bn.Digitals[0]) }, true, an.pos == bn.pos, true);
                }
                HPA temp = new HPA(bn);
                HPA re = new HPA(an);
                temp.pos = re.pos = true;
                if (re < temp) return re;
                int i = an.Len - bn.Len - (an.Digitals[an.Len - 1] >= bn.Digitals[bn.Len - 1] ? 0 : 1), q;
                for (q = 0; q < i; q++)
                    temp.Digitals.Insert(0, 0);
                while (temp.Len >= bn.Len)
                {
                    if (re.Len < temp.Len)
                    {
                        temp.Digitals.RemoveAt(0);
                        continue;
                    }
                    if (temp.Len > 1 && re.Len > 1)
                    {
                        if (re.Len == temp.Len) q = (re.Digitals[re.Len - 1] * 10 + re.Digitals[re.Len - 2]) / (temp.Digitals[temp.Len - 1] * 10 + temp.Digitals[temp.Len - 2]) - 1;
                        else if (re.Len > 2) q = (re.Digitals[re.Len - 1] * 100 + re.Digitals[re.Len - 2] * 10 + re.Digitals[re.Len - 3]) / (temp.Digitals[temp.Len - 1] * 10 + temp.Digitals[temp.Len - 2]) - 1;
                        else q = 0;
                        if (q > 0)
                        {
                            re -= temp * q;
                            while (!re.pos)
                            {
                                q -= 1;
                                re += temp;
                            }
                        }
                    }
                    if (!re.pos) throw new Exception();
                    while (!(re < temp))
                    {
                        re -= temp;
                    }
                    temp.Digitals.RemoveAt(0);
                }
                return re;
            }
            public static HPA[] ModDiv(HPA an, HPA bn)
            {
                if (an < bn) return new HPA[] { new HPA(Zero), new HPA(an) };
                HPA temp = new HPA(bn);
                HPA re = new HPA(an);
                temp.pos = re.pos = true;
                List<byte> rc = new List<byte>();
                int f = an.Digitals[an.Len - 1] >= bn.Digitals[bn.Len - 1] ? 0 : 1;
                int i = an.Len - bn.Len - f;
                for (int l = 0; l < i; l++)
                    temp.Digitals.Insert(0, 0);
                byte q;
                while (i >= 0)
                {
                    q = 0;
                    while (!(re < temp))
                    {
                        re -= temp;
                        q += 1;
                    }
                    temp.Digitals.RemoveAt(0);
                    rc.Add(q);
                    i--;
                }
                return new HPA[] { new HPA(rc, false, an.pos == bn.pos, true), new HPA(re.Digitals, true, an.pos == bn.pos, true) };
            }
            public static HPA operator !(HPA an)
            {
                HPA re = new HPA(an), temp = new HPA(One);
                while (re > One)
                {
                    temp *= re;
                    re -= One;
                }
                return temp;
            }
            /// <summary>
            /// 最大公约数
            /// </summary>
            /// <param name="n1"></param>
            /// <param name="n2"></param>
            /// <returns></returns>
            public static HPA Gcd(HPA n1, HPA n2)
            {
                if (n1 == One || n2 == One) return new HPA(One);
                HPA temp;
                while (n2 != Zero)
                {
                    temp = n2;
                    n2 = n1 % n2;
                    n1 = temp;
                }
                return n1;
            }
            /// <summary>
            /// 最小公倍数
            /// </summary>
            /// <param name="n1"></param>
            /// <param name="n2"></param>
            /// <returns></returns>
            public static HPA Lcm(HPA n1, HPA n2) => n1 * n2 / Gcd(n1, n2);
            /// <summary>
            /// x^(1/n)
            /// </summary>
            /// <param name="x"></param>
            /// <param name="n"></param>
            /// <returns></returns>

        }
        /// <summary>
        /// 三角形类
        /// </summary>
        public class Triangle
        {
            public QNum a { get; }
            public QNum b { get; }
            public QNum c { get; }
            public QNum cosA { get => ((b ^ 2) + (c ^ 2) - (a ^ 2)) / (b * c * 2); }
            public QNum cosB { get => ((a ^ 2) + (c ^ 2) - (b ^ 2)) / (a * c * 2); }
            public QNum cosC { get => ((b ^ 2) + (a ^ 2) - (c ^ 2)) / (b * a * 2); }
            public double sinA { get => Math.Sqrt(1 - (cosA ^ 2).Value); }
            public double sinB { get => Math.Sqrt(1 - (cosB ^ 2).Value); }
            public double sinC { get => Math.Sqrt(1 - (cosC ^ 2).Value); }
            public double A { get => Math.Acos(cosA.Value); }
            public double B { get => Math.Acos(cosB.Value); }
            public double C { get => Math.Acos(cosC.Value); }
            public QNum R { get => a / (new QNum(sinA)) / 2; }
            public double r { get => S / p.Value; }
            public double S { get => (a * b).Value * sinC / 2; }
            public QNum p { get => (a + b + c) / 2; }
            public QNum TA { get => (b + c - a) / 2; }
            public QNum TB { get => (a + c - b) / 2; }
            public QNum TC { get => (a + b - c) / 2; }
            public Triangle(QNum a, QNum b, QNum c)
            {
                this.a = a;
                this.b = b;
                this.c = c;
            }
            public Triangle(QNum a, QNum b, double C, bool IsSinC = false)
            {
                this.a = a;
                this.b = b;
                this.c = new QNum(Math.Sqrt(((a ^ 2) + (b ^ 2) - a * b * 2 * (IsSinC ? C : Math.Cos(C))).Value));
            }
            public Triangle(QNum a, double B, double C, bool IsSinB = false, bool IsSinC = false)
            {
                if (IsSinB == false && IsSinC == false)
                {
                    double siA = Math.Sin(B + C);
                    b = a * (Math.Sin(B) / siA);
                    c = a * (Math.Sin(C) / siA);
                    return;
                }
                if (IsSinB == true && IsSinC == true)
                {
                    double siA = B * Math.Sqrt(1 - C * C) + C * Math.Sqrt(1 - B * B);
                    b = a * (B / siA);
                    c = a * (C / siA);
                    return;
                }
                if (IsSinB == true && IsSinC == false)
                {
                    double siA = B * Math.Cos(C) + Math.Sin(C) * Math.Sqrt(1 - B * B);
                    b = a * (B / siA);
                    c = a * (Math.Sin(C) / siA);
                    return;
                }
                if (IsSinB == false && IsSinC == true)
                {
                    double siA = C * Math.Cos(B) + Math.Sin(B) * Math.Sqrt(1 - C * C);
                    b = a * (Math.Sin(B) / siA);
                    c = a * (C / siA);
                    return;
                }
            }
            public Triangle(Triangle source, QNum rate)
            {
                a = source.a * rate;
                b = source.b * rate;
                c = source.c * rate;
            }
            public static bool IsTriA(QNum a, QNum b, QNum c)
            {
                if (a <= QNum.Zero || b <= QNum.Zero || c <= QNum.Zero) return false;
                if (a + b <= c || b + c <= a) return false;
                return true;
            }
            public static List<Triangle> NumOfTri(QNum a, QNum b, double B)
            {
                List<Triangle> re = new List<Triangle>();
                double siB = Math.Sin(B);
                double siA = (a / b).Value * siB;
                if (siA == 1)
                {
                    re.Add(new Triangle(a, b, new QNum(Math.Sqrt(((a * a) - (b * b)).Value))));
                    return re;
                }
                if (siA <= siB)
                {
                    re.Add(new Triangle(a, b, siA * SinToCos(siB) + siB * SinToCos(siA)));
                    return re;
                }
                re.Add(new Triangle(a, b, siA * SinToCos(siB) + siB * SinToCos(siA)));
                re.Add(new Triangle(a, b, siA * SinToCos(siB) - siB * SinToCos(siA)));
                return re;
            }
            public List<PointS> Graph(PointS Og, double angle, QNum rate) => new List<PointS>
                {
                    Og,
                    new PointS(b * Math.Cos(angle) * rate, b * Math.Sin(angle) * rate),
                    new PointS(c * Math.Cos(angle + A) * rate, c * Math.Sin(angle + A) * rate)
                };
            public string GetAllInf()
            {
                return string.Concat(new string[]
                {
                    "a = " , a.ToString(),"\n",
                    "b = " , b.ToString(),"\n",
                    "c = " , c.ToString(),"\n",
                    "A = " , A.ToString(),"\n",
                    "B = " , B.ToString(),"\n",
                    "C = " , C.ToString(),"\n",
                    "sinA = " , sinA.ToString(),"\n",
                    "sinB = " , sinB.ToString(),"\n",
                    "sinC = " , sinC.ToString(),"\n",
                    "cosA = " , cosA.ToString(),"\n",
                    "cosB = " , cosB.ToString(),"\n",
                    "cosC = " , cosC.ToString(),"\n",
                    "r = " , r.ToString(),"\n",
                    "R = " , R.ToString(),"\n",
                    "S = " , S.ToString(),"\n",
                });
            }
        }
        /// <summary>
        /// 直线 Ax+By+C=0
        /// </summary>
        public class ELine : EqualationGM
        {
            public QNum K { get => Ids[0] / Ids[1] * -1; }
            public QNum D { get => Ids[2] / Ids[1] * -1; }
            public static ELine Basic = new ELine(new List<QNum>() { QNum.One, QNum.One, QNum.One });
            public List<QNum> Ids;
            public ELine(string s) : base(s)
            {
                if (items[0].power > 1) throw new Exception("ERROR:This is not ELine:" + s);
                SimpifyToInt();
            }
            public ELine(PointS a, PointS b)
            {
                if (a.x == b.x)
                {
                    items = new List<ItemEX>() { new ItemEX(QNum.One, 'x', 1), new ItemEX(a.x * -1) };
                }
                else if (a.y == b.y)
                {
                    items = new List<ItemEX>() { new ItemEX(QNum.One, 'y', 1), new ItemEX(a.y * -1) };
                }
                else items = new List<ItemEX>() { new ItemEX(b.y - a.y, 'x', 1), new ItemEX(a.x - b.x, 'y', 1), new ItemEX((a.y * b.x) - (a.x * b.y)) };
                Simpify(true);
                SimpifyToInt();
            }
            public ELine(QNum k, QNum dy)//y=kx+dy
            {
                if (k == QNum.Zero) items = new List<ItemEX>() { new ItemEX(QNum.One, 'y', 1), new ItemEX(dy * -1) };
                else items = new List<ItemEX>() { new ItemEX(k * -1, 'x', 1), new ItemEX(QNum.One, 'y', 1), new ItemEX(dy * -1) };
                Simpify(true);
                SimpifyToInt();
            }
            public ELine(IList<QNum> ids)
            {
                items = new List<ItemEX>()
                {
                    new ItemEX(ids[0],'x',1),
                    new ItemEX(ids[1],'y',1),
                    new ItemEX(ids[2])
                };
            }
            public void Simpify(bool simpled = false)
            {
                if (!simpled)
                    base.Simpify();
                Ids = Format(Basic);
            }
            /// <summary>
            /// 有交点
            /// </summary>
            /// <param name="a"></param>
            /// <param name="b"></param>
            /// <returns></returns>
            public static bool operator &(ELine a, ELine b) => a.K != b.K;
        }
        /// <summary>
        /// 线段
        /// </summary>
        public struct DLine
        {
            public PointS Point1;
            public PointS Point2;
            public DLine(PointS point1, PointS point2)
            {
                Point1 = point1;
                Point2 = point2;
            }
            public override string ToString() => Point1.ToString() + "->" + Point2.ToString();
        }
        /// <summary>
        /// 几何接口，提供绘图用函数
        /// </summary>
        public interface IGeometry
        {
            List<DLine> GraphP(QNum left, QNum right, QNum step);
        }
        /// <summary>
        /// 解析几何类
        /// </summary>
        public class EqualationGM : MultinomialEX, IGeometry
        {
            public EqualationGM(string s) : base(s.Contains("=") ? s.Substring(0, s.IndexOf('=')) : s)
            {
                List<char> cs = UnNs;
                if (cs.Count != 2 || !cs.Contains('x') || !cs.Contains('y')) throw new Exception("ERROR:EqualationGM don't have x y.");
                int i = s.IndexOf('=');
                if (i != -1)
                {
                    QNum t = new QNum(s.Substring(i + 1, s.Length - i - 1));
                    if (t == QNum.Zero) return;
                    if (items[items.Count - 1].power == 0)
                    {
                        if (items[items.Count - 1].qNum == t) items.RemoveAt(items.Count - 1);
                        else items[items.Count - 1].qNum -= t;
                    }
                    else items.Add(new ItemEX(t * -1));
                }
            }
            public EqualationGM() { }
            public Multinomial GetCutMul(char u, QNum value)
            {
                if (u != 'x' && u != 'y') throw new Exception("ERROR:EqualationGM.GetCutMul don't have x or y.");
                List<Item> ids = new List<Item>();
                foreach (ItemEX x in items)
                    ids.Add(new Item(x.qNum * (value ^ x.itemsWP[u]), x.itemsWP[u == 'x' ? 'y' : 'x']));
                return new Multinomial(ids);
            }
            public List<DLine> GraphP(QNum left, QNum right, QNum step)
            {
                List<DLine> re = new List<DLine>();
                List<QNum> sol;
                PointS t1 = PointS.Null, t2 = PointS.Null, k;
                while (left <= right)
                {
                    sol = GetCutMul('x', left).Solve();
                    if (sol != null)
                    {
                        foreach (QNum s in sol)
                        {
                            k = new PointS(left, s);
                            if (s >= QNum.Zero)
                            {
                                if (t1 != PointS.Null)
                                    re.Add(new DLine(t1, k));
                                t1 = k;
                            }
                            else
                            {
                                if (t2 != PointS.Null)
                                    re.Add(new DLine(t2, k));
                                t2 = k;
                            }
                        }
                    }
                    left += step;
                }
                return re;
            }
            public List<QNum> Solve(char u, QNum value) => GetCutMul(u, value).Solve();
            public override string ToString() => base.ToString() + "=0";
            /// <summary>
            /// 格式化，返回按照格式各项系数
            /// </summary>
            /// <param name="source"></param>
            /// <returns></returns>
            public List<QNum> Format(EqualationGM source)
            {
                int i = 0, t;
                ItemEX s;
                List<QNum> re = new List<QNum>();
                foreach (ItemEX x in source.items)
                {
                    t = FindItemIndex(x);
                    if (t != -1)
                    {
                        if (t != i)
                        {
                            s = items[t];
                            items[t] = items[i];
                            items[i] = s;
                            re.Add(s.qNum);
                            if (i >= items.Count) break;
                        }
                        else re.Add(items[t].qNum);
                        i += 1;
                    }
                    else re.Add(QNum.Zero);
                }
                while (re.Count < source.items.Count) re.Add(QNum.Zero);
                return re;
            }
            public ItemEX FindItem(ItemEX us)
            {
                foreach (ItemEX x in items)
                    if (x.IsFamily(us)) return x;
                return null;
            }
            public int FindItemIndex(ItemEX us)
            {
                for (int i = 0; i < items.Count; i++)
                    if (items[i].IsFamily(us)) return i;
                return -1;
            }
        }
        /// <summary>
        /// 圆锥曲线Ax^2+Bxy+Cy^2+Dx+Ey+F=0
        /// </summary>
        public class Conics : EqualationGM
        {
            public static Conics Basic = new Conics(new List<QNum>() { QNum.One, QNum.One, QNum.One, QNum.One, QNum.One, QNum.One });
            public List<QNum> Ids;
            public QNum E
            {
                get
                {
                    QNum t = Delta;
                    if (t > QNum.Zero) return new QNum(Math.Sqrt((Ids[0] > QNum.Zero ? QNum.One + Ids[0] / QNum.Abs(Ids[2]) : QNum.One + Ids[2] / QNum.Abs(Ids[0])).Value));
                    if (t == QNum.Zero) return QNum.One;
                    return new QNum(Math.Sqrt((Ids[0] < Ids[2] ? QNum.One - Ids[0] / Ids[2] : QNum.One - Ids[2] / Ids[0]).Value));
                }
            }
            public PointS F
            {
                get
                {
                    QNum t = Delta;
                    if (t > QNum.Zero) return new PointS(new QNum(Math.Sqrt((Ids[0].Reciprocal + Ids[2].Reciprocal).Value)), Ids[5] * -1);
                    if (t == QNum.Zero) return new PointS(Ids[0] == QNum.Zero ? Ids[3] / -4 : Ids[4] / -4, Ids[5] * -1);
                    return new PointS(new QNum(Math.Sqrt(QNum.Abs(Ids[0].Reciprocal - Ids[2].Reciprocal).Value)), Ids[5] * -1);
                }
            }
            public QNum Delta { get => (Ids[1] ^ 2) - (Ids[0] * Ids[2]) * 4; }
            public Conics(string s) : base(s)
            {
                if (items[0].power > 2) throw new Exception("ERROR:This is not Conics:" + s);
                Simpify(true);
            }
            /// <summary>
            /// Ax^2+Bxy+Cy^2+Dx+Ey+F=0
            /// </summary>
            /// <param name="ids"></param>
            public Conics(IList<QNum> ids)
            {
                items = new List<ItemEX>();
                for (int i = 0; i < 6; i++)
                {
                    if (ids[i] == QNum.Zero) continue;
                    switch (i)
                    {
                        case 0:
                            items.Add(new ItemEX(ids[i], 'x', 2));
                            break;
                        case 1:
                            ItemEX e = new ItemEX(ids[i]);
                            e.itemsWP['x'] = 1;
                            e.itemsWP['y'] = 1;
                            items.Add(e);
                            break;
                        case 2:
                            items.Add(new ItemEX(ids[i], 'y', 2));
                            break;
                        case 3:
                            items.Add(new ItemEX(ids[i], 'x', 1));
                            break;
                        case 4:
                            items.Add(new ItemEX(ids[i], 'y', 1));
                            break;
                        case 5:
                            items.Add(new ItemEX(ids[i]));
                            break;
                    }
                }

            }
            public void Simpify(bool simpled = false)
            {
                if (!simpled) base.Simpify();
                Ids = Format(Basic);
            }
        }
        /// <summary>
        /// 算式二叉树
        /// </summary>
        public class MultiManager
        {
            public Multinomial Q;
            public MultiManager A;
            public MultiManager P;
            /// <summary>
            /// Q*P+A
            /// </summary>
            public MultiManager(Multinomial q)
            {
                Q = q;
            }
            public static MultiManager ReadText(string s)
            {
                if (s.Length == 0) return null;
                int i, l, j;
                while ((i = MatchString(s, ")^")) != -1)
                {
                    j = MatchKuo(s, i);
                    l = MatchNum(s, i + 2);
                    string c = s.Substring(j, i + 1 - j);
                    for (int k = l; k > 1; k--) c += s.Substring(j, i + 1 - j);
                    s = s.Substring(0, j) + c + s.Substring(i + 2 + l.ToString().Length);
                }
                i = s.IndexOf('(');
                l = 0;
                if (i == -1) return new MultiManager(new Multinomial(s));
                else if (i == 0 && s.IndexOf(")") == s.Length - 1)
                    return new MultiManager(new Multinomial(s.Substring(1, s.Length - 2)));
                if (i == 0 && (s[s.Length - 1] == ')' || (s[s.Length - 1] == 'x' && s[s.Length - 2] == ')')))
                {
                    for (j = i; j < s.Length; j++)
                    {
                        if (s[j] == '(') l += 1;
                        else if (s[j] == ')') l -= 1;
                        if (l == 0) break;
                    }
                    if (j == s.Length - 1) return ReadText(s.Substring(1, s.Length - 2));
                    else return new MultiManager(new Multinomial(s.Substring(1, j - 1))) { P = ReadText(s.Substring(j + 1)) };
                }
                Multinomial qt;
                for (j = i - 1; j >= 0 && IsItem(s[j]); j--) ;
                if (j >= 0 && s[j] == '-') j -= 1;
                if (i - 1 - j <= 0) qt = new Multinomial(Multinomial.One);
                else qt = new Multinomial(s.Substring(j + 1, i - 1 - j));
                string ts = j > 0 ? s.Substring(0, j) : "";
                for (j = i; j < s.Length; j++)
                {
                    if (s[j] == '(') l += 1;
                    else if (s[j] == ')') l -= 1;
                    if (l == 0)
                    {
                        if (j < s.Length - 1 && s[j + 1] != '+' && s[j + 1] != '-') continue;
                        else break;
                    }
                }
                if (j < s.Length - 1) ts += s.Substring(j + 1, s.Length - j - 1);
                return new MultiManager(qt) { A = ReadText(ts), P = ReadText(s.Substring(i, j - i + 1)) };
            }
            public QNum Compute(QNum x)
            {
                if (A == null || P == null) return Q.Compute(x);
                else return Q.Compute(x) * P.Compute(x) + A.Compute(x);
            }
            private Multinomial SimpifyWork() => A == null ? (P == null ? Q : Q * P.SimpifyWork()) : (P == null ? Q : Q * P.SimpifyWork()) + A.SimpifyWork();
            public Multinomial Simpify()
            {
                Multinomial re = SimpifyWork();
                re.Simpify();
                return re;
            }
            public override string ToString()
            {
                string a = A == null ? "" : A.ToString();
                if (a.Length > 0 && a[0] != '-') a = "+" + a;
                return (P == null ? Q.ToString() : (Q.items.Count > 1 ? ("(" + Q.ToString() + ")") : (Q == Multinomial.One ? "" : Q.ToString())) + "(" + P.ToString() + ")") + a;
            }
        }
        /// <summary>
        /// 递推数列类
        /// </summary>
        public class RecursionArray
        {
            public Multinomial multinomial;
            public QNum a;
            public RecursionArray(Multinomial multinomial, QNum a)
            {
                this.multinomial = multinomial;
                this.a = a;
            }
            public QNum Compute(int n)
            {
                QNum re = a;
                for (; n > 1; n--)
                    re = multinomial.Compute(re);
                return re;
            }
            public HPAQNum ComputeHPA(int n)
            {
                HPAQNum re = new HPAQNum(a);
                for (; n > 1; n--)
                    re = multinomial.Compute(re);
                return re;
            }
            public List<QNum> ComputeLi(int n)
            {
                QNum t = a;
                List<QNum> re = new List<QNum>() { t };
                for (; n > 1; n--)
                {
                    t = multinomial.Compute(t);
                    re.Add(t);
                }
                return re;
            }
            public Multinomial TrySolve(int n) => Multinomial.Lagrange(GetPointsFromValue(ComputeLi(n), QNum.One, QNum.One));
        }
        /// <summary>
        /// 范围结构
        /// </summary>
        public struct Range
        {
            public QNum Left;
            public QNum Right;
            public bool LeftE;
            public bool RightE;
            public QNum Length { get => Right - Left; }

            public Range(QNum left, QNum right, bool leftE, bool rightE)
            {
                Left = left;
                Right = right;
                LeftE = leftE;
                RightE = rightE;
            }
            /// <summary>
            /// (a,b)、[a,b]
            /// </summary>
            /// <param name="s"></param>
            public Range(string s)
            {
                LeftE = s[0] == '[';
                RightE = s[s.Length - 1] == ']';
                int i = s.IndexOf(',');
                Left = new QNum(s.Substring(1, i - 1));
                Right = new QNum(s.Substring(i + 1, s.Length - i - 2));
            }
            /// <summary>
            /// [l,r]
            /// </summary>
            /// <param name="l"></param>
            /// <param name="r"></param>
            public Range(int l, int r)
            {
                RightE = true;
                LeftE = true;
                Left = new QNum(l);
                Right = new QNum(r);
            }
            public bool IsIn(QNum n)
            {
                if (LeftE && RightE) return n >= Left && n <= Right;
                if (!LeftE && !RightE) return n > Left && n < Right;
                if (!LeftE && RightE) return n > Left && n <= Right;
                if (LeftE && !RightE) return n >= Left && n < Right;
                throw new Exception("Error:Range IsIn error.");
            }
            public override string ToString() => (LeftE ? "[" : "(") + Left.ToString() + "," + Right.ToString() + (RightE ? "]" : ")");
        }
        public class RNum
        {
            public HPAQNum Num;
            public RNum A;
            public RNum B;
            public Notes Note;
            public string P;
            public static readonly RNum Two = new RNum(HPAQNum.Two);
            public static readonly RNum One = new RNum(HPAQNum.One);
            public static readonly RNum Zero = new RNum(HPAQNum.Zero);
            public static readonly RNum Mine = new RNum(HPAQNum.Mine);
            public static readonly RNum Null = new RNum(HPAQNum.Null);
            public bool IsNum { get => !Num.Equals(HPAQNum.Null); }
            public bool IsPara { get => P != string.Empty; }
            public bool OnlyNum { get => IsNum && !IsPara; }
            public int Lenth
            {
                get
                {
                    if (IsNum) return 1;
                    return A.Lenth + B.Lenth;
                }
            }
            public RNum(RNum a, RNum b, Notes note)
            {
                A = a;
                B = b;
                Note = note;
                P = string.Empty;
                Num = HPAQNum.Null;
            }
            public RNum(HPAQNum n)
            {
                Num = n;
                Note = Notes.Empty;
                P = string.Empty;
            }
            public RNum(HPAQNum n, string p)
            {
                Num = n;
                Note = Notes.Empty;
                P = p;
            }
            public RNum(string s)
            {
                if (s.Length == 0)
                {
                    Num = new HPAQNum(HPAQNum.Zero);
                    P = string.Empty;
                    Note = Notes.Empty;
                }
                Num = new HPAQNum(HPAQNum.One);
                P = "";
                int i = 0, l = 0;
                for (; i < s.Length; i++)
                {
                    if (IsAlpha(s[i]) || s[i] == '+' || s[i] == '.') continue;
                    if (i - l > 0)
                    {
                        Num *= new HPAQNum(s.Substring(l, i - l));
                    }
                    l = i + 1;
                    if (s[i] == '-') Num *= HPAQNum.Mine;
                    else P += s[i];
                }
                if (i - l > 0)
                {
                    Num *= new HPAQNum(s.Substring(l, i - l));
                }
            }
            public RNum(RNum rNum)
            {
                if (rNum.IsNum)
                {
                    Num = new HPAQNum(rNum.Num);
                    Note = Notes.Empty;
                    P = rNum.P;
                    return;
                }
                Note = rNum.Note;
                P = rNum.P;
                if (!rNum.A.Equals(null))
                    A = new RNum(rNum.A);
                if (!rNum.B.Equals(null))
                    B = new RNum(rNum.B);
                Num = HPAQNum.Null;
            }
            public RNum()
            {
                Note = Notes.Empty;
                P = string.Empty;
                Num = HPAQNum.Null;
            }
            private void TurnToNum(HPAQNum num)
            {
                Note = Notes.Empty;
                A = null;
                B = null;
                Num = num;
            }
            public HPAQNum Compute(Dictionary<string, HPAQNum> Values)
            {
                if (IsNum)
                {
                    if (IsPara) return Num * Values[P];
                    else return new HPAQNum(Num);
                }
                switch (Note)
                {
                    case Notes.Add:
                        return A.Compute(Values) + B.Compute(Values);
                    case Notes.Minus:
                        return A.Compute(Values) - B.Compute(Values);
                    case Notes.Down:
                        return A.Compute(Values) / B.Compute(Values);
                    case Notes.Multiply:
                        return A.Compute(Values) * B.Compute(Values);
                    case Notes.Power:
                        return A.Compute(Values) ^ B.Compute(Values);
                }
                throw new Exception("RNum Compute ERROR!");
            }
            private void TurnTo(RNum X)
            {
                Note = X.Note;
                P = X.P;
                Num = X.Num;
                A = X.A;
                B = X.B;
            }
            private static RNum ToRNumNoKuo(string s)
            {
                if (s.Length == 1)
                {
                    if (s == "+") return new RNum(One);
                    if (s == "-") return new RNum(Mine);
                    return new RNum(s);
                }
                int i = s.IndexOf('+');
                if (i != -1 && i != 0) return new RNum(ToRNumNoKuo(s.Substring(0, i)), ToRNumNoKuo(s.Substring(i + 1)), Notes.Add);
                i = s.LastIndexOf('-');
                if (i != -1 && i != 0) return new RNum(ToRNumNoKuo(s.Substring(0, i)), ToRNumNoKuo(s.Substring(i + 1)), Notes.Minus);
                i = s.LastIndexOf('*');
                if (i != -1) return new RNum(ToRNumNoKuo(s.Substring(0, i)), ToRNumNoKuo(s.Substring(i + 1)), Notes.Multiply);
                i = s.LastIndexOf('/');
                if (i != -1) return new RNum(ToRNumNoKuo(s.Substring(0, i)), ToRNumNoKuo(s.Substring(i + 1)), Notes.Down);
                i = s.IndexOf('^');
                if (i != -1) return new RNum(ToRNumNoKuo(s.Substring(0, i)), ToRNumNoKuo(s.Substring(i + 1)), Notes.Power);
                return new RNum(s);
            }
            private static RNum ToRNumWK(string s)
            {
                if (s.Length == 1)
                {
                    if (s == "+") return new RNum(One);
                    if (s == "-") return new RNum(Mine);
                    return new RNum(s);
                }
                int i = s.IndexOf('(');
                if (i == -1) return ToRNumNoKuo(s);
                int k = MatchKuo(s, i);
                if (i == 0 && k == s.Length - 1) return ToRNumWK(s.Substring(1, s.Length - 2));
                i = IndexOfWD(s, '+', 0);
                if (i != -1 && i != 0) return new RNum(ToRNumWK(s.Substring(0, i)), ToRNumWK(s.Substring(i + 1)), Notes.Add);
                i = LastIndexOfWD(s, '-', 0);
                if (i != -1 && i != 0) return new RNum(ToRNumWK(s.Substring(0, i)), ToRNumWK(s.Substring(i + 1)), Notes.Minus);
                i = LastIndexOfWD(s, '*', 0);
                if (i != -1) return new RNum(ToRNumWK(s.Substring(0, i)), ToRNumWK(s.Substring(i + 1)), Notes.Multiply);
                i = LastIndexOfWD(s, '/', 0);
                if (i != -1) return new RNum(ToRNumWK(s.Substring(0, i)), ToRNumWK(s.Substring(i + 1)), Notes.Down);
                i = IndexOfWD(s, '^', 0);
                if (i != -1) return new RNum(ToRNumWK(s.Substring(0, i)), ToRNumWK(s.Substring(i + 1)), Notes.Power);
                return new RNum(s);
                
            }
            public static RNum ToRNumWP(string s)
            {
                int i = 1;
                while (i < s.Length)
                {
                    if (!IsAlpha(s[i]))
                    {
                        if (s[i] == '(' && !IsNote(s[i - 1]) && s[i - 1] != '(' && s[i - 1] != ')')
                            s = s.Insert(i++, "*");
                        else if (s[i] == '(' && s[i - 1] == ')')
                            s = s.Insert(i++, "*");
                        else if (s[i] == ')' && i < s.Length - 1 && !IsNote(s[i + 1]) && s[i + 1] != '(' && s[i + 1] != ')')
                            s = s.Insert(++i, "*");
                        else if (s[i] != '(' && s[i] != ')' && !IsNote(s[i]) && IsAlpha(s[i - 1]))
                            s = s.Insert(i++, "*");
                        else if (!IsNote(s[i]) && s[i] != '(' && s[i] != ')' && s[i - 1] == '-')
                        {
                            s = s.Insert(i, "1*");
                            i += 2;
                        }
                    }
                    i += 1;//(x^2+(a-2)(a-4))/((x^2+(a-2)^2)(x^2+(a-4)^2))
                }
                return ToRNumWK(s);
            }
            private void Swap()
            {
                RNum t = A;
                A = B;
                B = t;
            }
            private void Multi(HPAQNum n)
            {
                if (IsNum) Num *= n;
                else if (Note == Notes.Add || Note == Notes.Minus)
                {
                    A.Multi(n);
                    B.Multi(n);
                }
                else TurnTo(new RNum(n) * new RNum(this));
            }
            private void OpetNote(bool ops=true)
            {
                if (IsNum)
                {
                    if (ops) Num.pos = !Num.pos;
                    return;
                }
                if (Note == Notes.Add)
                {
                    A.OpetNote(ops);
                    B.OpetNote(ops);
                }
                else if (Note == Notes.Minus)
                {
                    Note = Notes.Add;
                    A.OpetNote(ops);
                    B.OpetNote(!ops);
                }
                else if (ops&&Note!=Notes.Power)
                {
                    A.OpetNote(ops);
                }
            }
            private void SimpifyP()
            {
                if(!A.IsNum)
                    A.SimpifyP();
                if (!B.IsNum)
                    B.SimpifyP();
                SimpifyL();
                if (IsNum) return;
                if (A.IsNum && B.IsNum)
                {
                    switch (Note)
                    {
                        case Notes.Add:
                            if (A.P != B.P) return;
                            P = A.P;
                            TurnToNum(A.Num + B.Num);
                            if (Num == HPAQNum.Zero) P = string.Empty;
                            return;
                        case Notes.Minus:
                            if (A.P != B.P)return;
                            P = A.P;
                            TurnToNum(A.Num - B.Num);
                            if (Num == HPAQNum.Zero) P = string.Empty;
                            return;
                        case Notes.Down:
                            if (B.Num == HPAQNum.Zero)
                            {
                                throw new Exception("Divisor is Zero.");
                            }
                            if (A.P != B.P)
                            {
                                A.Num /= B.Num;
                                if (!B.IsPara) TurnTo(A);
                                else B.Num = new HPAQNum(HPAQNum.One);
                                return;
                            }
                            HPAQNum tq = A.Num / B.Num;
                            tq.Simpify();
                            TurnToNum(tq);
                            return;
                        case Notes.Multiply:
                            if (A.P == string.Empty)
                            {
                                P = B.P;
                                TurnToNum(A.Num * B.Num);
                                return;
                            }
                            A.Num *= B.Num;
                            B.Num = new HPAQNum(HPAQNum.One);
                            if (A.P == B.P)
                            {
                                A.P = string.Empty;
                                B ^= new RNum(Two);
                            }
                            return;
                        case Notes.Power:
                            if (A.P != B.P||A.P!=string.Empty) return;
                            if (!A.Num.pos && B.Num.Down != HPA.One) return;
                            TurnToNum(A.Num ^ B.Num);
                            return;
                    }
                    throw new Exception();
                }
                if (Note == Notes.Down)
                {
                    B ^= new RNum(Mine);
                    Note = Notes.Multiply;
                    TurnTo(Item.GetItem(this).ToRNum());
                    return;
                }
                if (Note == Notes.Power)
                {
                    if (!B.OnlyNum||B.Num.Down!=HPA.One||B.Num.Up.Len>1) return;
                    if (!B.Num.pos) return;
                    HPA tp = B.Num.Up;
                    RNum t = A;
                    while (true)
                    {
                        A *= new RNum(t);
                        if (tp == HPA.Two) {break; }
                        tp -= HPA.One;
                    }
                    TurnTo(A);
                }
                if (Note == Notes.Multiply)
                {
                    if (A.IsNum) Swap();
                    else if (B.Note == Notes.Add || B.Note == Notes.Minus) Swap();
                    if (A.Note == Notes.Add || A.Note == Notes.Minus)
                    {
                        A.A *= B;
                        A.B *= new RNum(B);
                        TurnTo(A);
                        SimpifyP();
                        return;
                    }
                    TurnTo(Item.GetItem(this).ToRNum());
                    return;
                }
                TurnTo(Item.ToRNum(Item.GetItems(this)));
                return;
            }
            public void Simpify()
            {
                if (IsNum) return;
                SimpifyP();
                SimpifyL();
                SimpifyM();

            }
            private void SimpifyL()
            {
                if (IsNum) return;
                A.SimpifyL();
                B.SimpifyL();
                switch (Note)
                {
                    case Notes.Add:
                        if (A.Num == HPAQNum.Zero) TurnTo(B);
                        else if (B.Num == HPAQNum.Zero) TurnTo(A);
                        return;
                    case Notes.Minus:
                        if (A.Num == HPAQNum.Zero) { B.Multi(HPAQNum.Mine); TurnTo(B); }
                        else if (B.Num == HPAQNum.Zero) TurnTo(A);
                        return;
                    case Notes.Down:
                        if (A.Num == HPAQNum.Zero) TurnTo(new RNum(Zero));
                        else if (B.OnlyNum&&B.Num == HPAQNum.One) TurnTo(A);
                        else if (!B.IsNum && B.Note == Notes.Down && B.A.Num == HPAQNum.One)
                        {
                            Note = Notes.Multiply;
                            B.TurnTo(B.B);
                        }
                        return;
                    case Notes.Multiply:
                        if (A.Num == HPAQNum.Zero || B.Num == HPAQNum.Zero) TurnTo(new RNum(Zero));
                        else if (B.OnlyNum && B.Num == HPAQNum.One) TurnTo(A);
                        else if (A.OnlyNum && A.Num == HPAQNum.One) TurnTo(B);
                        return;
                    case Notes.Power:
                        if (A.Num == HPAQNum.Zero) TurnTo(new RNum(Zero));
                        else if (A.OnlyNum && A.Num == HPAQNum.One) TurnTo(A);
                        else if (B.Num == HPAQNum.Zero) TurnTo(new RNum(One));
                        else if (B.OnlyNum && B.Num == HPAQNum.One) TurnTo(A);
                        return;
                }
            }
            private void SimpifyM()
            {
                if (IsNum) return;
                if(!A.IsNum)
                A.SimpifyM();
                if(!B.IsNum)
                B.SimpifyM();
                if (B.IsNum && !B.Num.pos)
                {
                    if (Note == Notes.Add) Note = Notes.Minus;
                    else if (Note == Notes.Minus) Note = Notes.Add;
                    else goto Next;
                    B.Num.pos = !B.Num.pos;
                    return;
                }
                Next:
                if (!B.IsNum)
                {
                    if (Note == Notes.Multiply)
                    {
                        if (B.Note == Notes.Power&&B.B.OnlyNum)
                        {
                            if (!B.B.Num.pos)
                            {
                                Note = Notes.Down;
                                if (B.B.Num == HPAQNum.Mine)
                                    B.TurnTo(B.A);
                                else B.B.Num.pos = true;
                                return;
                            }
                        }
                    }
                }
            }
            public MultinomialEX ToMultinoal()
            {
                List<Item> its = Item.GetItems(new RNum(this));
                MultinomialEX re = new MultinomialEX();
                re.items = new List<ItemEX>();
                foreach (Item x in its)
                    re.items.Add(x.ToItemEX());
                return re;
            }
            public bool ContainNote(Notes note)
            {
                if (IsNum) return false;
                if (Note == note) return true;
                return A.ContainNote(note) || B.ContainNote(note);
            }
            public string ToString(Notes BasNote,bool front)
            {
                if (IsNum)
                {
                    if (IsPara) return Num.ToString(true, true) + P;
                    else return Num.ToString(false, true);
                }
                string Ast = A.ToString(Note, false), Bst = B.ToString(Note, true);
                switch (Note)
                {
                    case Notes.Add:
                        if(BasNote==Notes.Add||(!front&&BasNote==Notes.Minus)) return Ast + "+" + Bst;
                        return "(" + Ast + "+" + Bst + ")";
                    case Notes.Down:
                        if (BasNote==Notes.Minus||BasNote==Notes.Add||BasNote==Notes.Multiply||(!front&&BasNote==Notes.Down)) return Ast + "/" + Bst;
                        return "(" + Ast + "/" + Bst + ")";
                    case Notes.Minus:
                        if (BasNote == Notes.Minus || BasNote == Notes.Add || BasNote ==Notes.Add||(!front&&BasNote==Notes.Minus)) return  Ast + "-" + Bst;
                        return "(" + Ast + "-" + Bst + ")";
                    case Notes.Multiply:
                        if (BasNote == Notes.Minus || BasNote == Notes.Add || BasNote ==Notes.Multiply||(!front&&BasNote==Notes.Down)) return  Ast + "*" + Bst;
                        return "(" + Ast + "*" + Bst + ")";
                    case Notes.Power:
                        if ((front&&BasNote==Notes.Down)) return "(" + Ast + "^" + Bst + ")";
                        return Ast + "^" + Bst;
                    default:
                        throw new Exception("Note exhanst!");
                }
            }
            public override string ToString() => ToString(Notes.Add,true);
            public List<string> GetPs()
            {
                List<string> re = new List<string>();
                if (IsPara)
                {
                    re.Add(P);
                    return re;
                }
                if (IsNum) return re;
                re = A.GetPs();
                List<string> te = B.GetPs();
                foreach (string x in te)
                    if (!re.Contains(x)) re.Add(x);
                return re;
            }
            public void Replace(Dictionary<string,HPAQNum> Values)
            {
                if (IsPara&&Values.ContainsKey(P))
                {
                    Num *= Values[P];
                    P = string.Empty;
                    return;
                }
                if (IsNum) return;
                A.Replace(Values);
                B.Replace(Values);
            }
            public void Replace(Dictionary<string, RNum> Values)
            {
                if (IsPara && Values.ContainsKey(P))
                {
                    TurnTo(new RNum(Values[P]));
                    return;
                }
                if (IsNum) return;
                A.Replace(Values);
                B.Replace(Values);
            }
            public void Replace(Dictionary<RNum, RNum> Values)
            {
                RNum t;
                if (!(t=Item.ContainsK(this,Values)).Equals(Null))
                {
                    TurnTo(new RNum(Values[t]));
                    return;
                }
                if (IsNum) return;
                A.Replace(Values);
                B.Replace(Values);
            }
            public List<RNum> GetDownS()
            {
                if (IsNum)
                    if (Num.Down == HPA.One) return new List<RNum>();
                    else return new List<RNum> { new RNum(new HPAQNum(Num.Down, false)) };
                if (Note == Notes.Power) return new List<RNum>();
                List<RNum> re = A.GetDownS();
                if (Note == Notes.Down)
                {
                    re.Add(new RNum(B));
                    return re;
                }
                re.AddRange(B.GetDownS());
                return re;
            }
            public void Derivation(string x)
            {
                if (IsNum)
                {
                    if (P != x) Num = new HPAQNum(HPAQNum.Zero);
                    P = string.Empty;
                }
                switch (Note)
                {
                    case Notes.Add:
                        A.Derivation(x);
                        B.Derivation(x);
                        break;
                    case Notes.Minus:
                        A.Derivation(x);
                        B.Derivation(x);
                        break;
                    case Notes.Down:
                        RNum ta = new RNum(A), tb = new RNum(B);
                        ta.Derivation(x);
                        tb.Derivation(x);
                        A = (ta * new RNum(B)) - (tb * new RNum(A));
                        B ^= new RNum(Two);
                        break;
                    case Notes.Multiply:
                        RNum ta2 = new RNum(A), tb2 = new RNum(B);
                        ta2.Derivation(x);
                        tb2.Derivation(x);
                        A *= tb2;
                        B *= ta2;
                        Note = Notes.Add;
                        break;
                    case Notes.Power:
                        RNum temp = B;
                        B = A ^ (new RNum(B) - new RNum(One));
                        A = temp;
                        Note = Notes.Multiply;
                        break;
                }
                Simpify();
            }
            public List<RNum> FindRNums(RNum source)
            {
                if (this == source) return new List<RNum> { this };
                if (IsNum) return new List<RNum>();
                List<RNum> re = A.FindRNums(source);
                re.AddRange(B.FindRNums(source));
                return re;
            }
            public RNum AdsorbRNum(RNum p)
            {
                List<Item> its = Item.GetItems(new RNum(this));
                Dictionary<RNum, RNum> powerTPara = new Dictionary<RNum, RNum>();
                RNum t, t2,t3,t4,fromer=Null;
                foreach(Item x in its)
                {
                    t = x.ContainsK(p);
                    if (t.Equals(Null))
                    {
                        if (fromer.Equals(Null)) fromer = x.ToRNum();
                        else fromer += x.ToRNum();
                        continue;
                    }
                    t3 = x.powers[t];
                    x.powers.Remove(t);
                    t2 = x.ToRNum();
                    t4 = Item.ContainsK(t3, powerTPara);
                    if (t4.Equals(Null)) powerTPara[t3] = t2;
                    else powerTPara[t4] += t2;
                }
                List<RNum> tl = new List<RNum>(powerTPara.Keys);
                tl.Sort((RNum a, RNum b) => a.IsNum && b.IsNum ? (b.Num - a.Num).ToInt() : b.Lenth - a.Lenth);
                RNum re = Null;
                bool pos;
                foreach (RNum x in tl)
                {
                    powerTPara[x].Simpify();
                    if (powerTPara[x].IsNum && !powerTPara[x].Num.pos)
                    {
                        powerTPara[x].Num.pos = true;
                        pos = false;
                    }
                    else pos = true;
                    t2 = new RNum(p);
                    if (powerTPara[x].OnlyNum&&( powerTPara[x].Num == HPAQNum.One|| powerTPara[x].Num == HPAQNum.Mine))
                    {
                            t = x == One ? t2 : t2 ^ x;
                    }
                    else t = powerTPara[x] * (x == One ? t2 : t2 ^ x);
                    if (re.Equals(Null))
                    {
                        if(pos) re = t;
                        else
                        {
                            if (t.IsNum) t.Num.pos = false;
                            else t = new RNum(Mine) * t;
                            re = t;
                        }
                    }
                    else if (pos) re += t;
                    else re -= t;
                }
                if (fromer.Equals(Null)) return re;
                fromer.Simpify();
                if (fromer.IsNum && !fromer.Num.pos)
                {
                    fromer.Num.pos = true;
                    return re - fromer;
                }
                return re+fromer;
            }
            public static RNum operator +(RNum a, RNum b) => new RNum(a, b, Notes.Add);
            public static RNum operator -(RNum a, RNum b) => new RNum(a, b, Notes.Minus);
            public static RNum operator *(RNum a, RNum b) => new RNum(a, b, Notes.Multiply);
            public static RNum operator /(RNum a, RNum b) => new RNum(a, b, Notes.Down);
            public static RNum operator ^(RNum a, RNum b) => new RNum(a, b, Notes.Power);
            public static bool operator ==(RNum a,RNum b)
            {
                if (a.Equals(b)) return true;
                if (a.P != b.P || a.Note != b.Note || a.Num != b.Num) return false;
                if (a.IsNum && b.IsNum) return true;
                if (a.IsNum || b.IsNum) return false; 
                if (a.Note == b.Note&&(a.Note==Notes.Add||a.Note==Notes.Multiply))
                    return (a.A == b.A && a.B == b.B)|| (a.A == b.B && a.B == b.A);
                return a.A == b.A && a.B == b.B;
            }
            public static bool operator !=(RNum a, RNum b) => !(a == b);
            public static bool IsNote(char c) => c == '+' || c == '-' || c == '*' || c == '/' || c == '^';
            public class Item
            {
                public HPAQNum Para;
                public Dictionary<RNum, RNum> powers;
                public static List<RNum> temp = new List<RNum>();
                public static int SortPos = 1;
                public static Item GetItemL(RNum rNum)
                {
                    if (rNum.IsNum)
                    {
                        if (rNum.IsPara)
                        {
                            HPAQNum para = rNum.Num;
                            rNum.Num = new HPAQNum(HPAQNum.One);
                            return new Item
                            {
                                Para = para,
                                powers = new Dictionary<RNum, RNum> { [rNum] = new RNum(One) }
                            };
                        }
                        else return new Item { Para = new HPAQNum(rNum.Num), powers = new Dictionary<RNum, RNum>() };
                    }
                    if (rNum.Note == Notes.Power)
                    {
                        if (rNum.A.IsNum)
                        {
                            HPAQNum temp;
                            if (rNum.B.OnlyNum)
                            {
                                temp = rNum.A.Num ^ rNum.B.Num;
                                rNum.A.Num = new HPAQNum(HPAQNum.One);
                            }
                            else temp = new HPAQNum(HPAQNum.One);
                            return new Item
                            {
                                Para = temp,
                                powers = new Dictionary<RNum, RNum> { [rNum.A] = rNum.B }
                            };
                        }
                        Item t = GetItem(rNum.A);
                        t.Para ^= rNum.B.Num;
                        t.Para.Simpify();
                        List<RNum> rns = new List<RNum>(t.powers.Keys);
                        foreach(RNum x in rns)
                        {
                            t.powers[x] *= rNum.B;
                            t.powers[x].Simpify();
                        }
                        return t;
                    }
                    if (rNum.Note == Notes.Multiply)
                    {
                        if (rNum.A.Note == Notes.Power) rNum.Swap();
                        Item at = GetItem(rNum.A);
                        Item bt = GetItem(rNum.B);
                        at.Para *= bt.Para;
                        at.Para.Simpify();
                        foreach(RNum x in bt.powers.Keys)
                         {
                            RNum t = at.ContainsK(x);
                                if (!t.Equals(Null))
                                {
                                    at.powers[t] += bt.powers[x];
                                    at.powers[t].Simpify();
                                }
                                else at.powers[x] = bt.powers[x];
                         }
                         return at;
                    }
                    return new Item
                    {
                        Para = new HPAQNum(HPAQNum.One),
                        powers = new Dictionary<RNum, RNum> { [rNum] = new RNum(One) }
                    };
                }
                public static Item GetItem(RNum rNum)
                {
                    Item re = GetItemL(rNum);
                    re.Simpify();
                    return re;
                }
                public void Simpify()
                {
                    foreach (RNum x in powers.Keys)
                    {
                        if (!x.IsNum) continue;
                        if (powers[x].Num == HPAQNum.Zero)
                        {
                            temp.Add(x);
                            continue;
                        }
                        if (x.IsNum&&powers[x].OnlyNum&& powers[x].Num.Down==HPA.One)
                        {
                            if (powers[x].Num.Up % HPA.Two == HPA.Zero) x.Num.pos = true;
                            else if (x.Num.pos == false)
                            {
                                Para.pos = !Para.pos;
                                x.Num.pos = true;
                            }
                        }
                    }
                    if (temp.Count > 0)
                    {
                        foreach (RNum x in temp)
                            powers.Remove(x);
                        temp.Clear();
                    }
                }
                public static List<Item> GetItems(RNum rNum)
                {
                    if (rNum.Note==Notes.Add||rNum.Note==Notes.Minus)
                    {
                        List<Item> As = GetItems(rNum.A);
                        List<Item> Bs = GetItems(rNum.B);
                        if (rNum.Note == Notes.Minus)
                            foreach (Item x in Bs)
                                x.Para.pos = !x.Para.pos;
                        int i = 0,j;
                        while (i < As.Count)
                        {
                            j = 0;
                            while (j < Bs.Count)
                            {
                                if (As[i].IsFamily(Bs[j]))
                                {
                                    As[i].Para += Bs[j].Para;
                                    Bs.RemoveAt(j);
                                }
                                else j += 1;
                            }
                            if (As[i].Para == HPAQNum.Zero)
                                As.RemoveAt(i);
                            else i += 1;
                        }
                        As.AddRange(Bs);
                        return As;
                    }
                    return new List<Item> { GetItem(rNum) };
                }
                public bool IsFamily(Item item)
                {
                    if (item.powers.Keys.Count != powers.Keys.Count) return false;
                    RNum t;
                    foreach (RNum x in powers.Keys)
                    {
                        t = item.ContainsK(x);
                        if (t == Null) return false;
                        else if (powers[x] != item.powers[t]) return false;
                    }
                    return true;
                }
                public RNum ContainsK(RNum n)
                {
                    foreach (RNum x in powers.Keys)
                        if (n == x) return x;
                    return Null;
                }
                public static RNum ContainsK(RNum n,Dictionary<RNum,RNum> powers)
                {
                    foreach (RNum x in powers.Keys)
                        if (n == x) return x;
                    return Null;
                }
                public override string ToString()
                {
                    string re = Para.ToString();
                    foreach(RNum x in powers.Keys)
                    {
                        re += " *(" + x.ToString() + ")^" + powers[x].ToString();
                    }
                    return re;
                }
                public RNum ToRNum()
                {
                    if (powers.Count == 0) return new RNum(Para);
                    temp = new List<RNum>(powers.Keys);
                    temp.Sort(Sort);
                    RNum re;
                    if (powers[temp[0]].OnlyNum && powers[temp[0]].Num == HPAQNum.One) re = temp[0];
                    else re = temp[0] ^ powers[temp[0]];
                    for (int i=1;i<temp.Count;i++)
                    {
                        if (powers[temp[i]].OnlyNum && powers[temp[i]].Num == HPAQNum.One) re *= temp[i];
                        else re *= temp[i] ^ powers[temp[i]];
                    }
                    if (Para != HPAQNum.One) re = new RNum(Para) * re;
                    temp.Clear();
                    return re;
                }
                public static RNum ToRNum(List<Item> items)
                {
                    items.Sort(Sort);
                    RNum re = items[0].ToRNum();
                    for (int i = 1; i < items.Count; i++)
                    {
                        if (items[i].Para.pos) re += items[i].ToRNum();
                        else
                        {
                            items[i].Para.pos = true;
                            re-= items[i].ToRNum();
                        }
                    }
                    return re;
                }
                public ItemEX ToItemEX()
                {
                    ItemEX re = new ItemEX(Para.ToQNum());
                    foreach(RNum x in powers.Keys)
                    {
                        if (!x.IsNum || !powers[x].OnlyNum || powers[x].Num.Down != HPA.One || x.P.Length > 1) throw new Exception("ToItem Failed!");
                        re.itemsWP[x.P[0]] = powers[x].Num.Up.ToInt();
                    }
                    return re;
                }
                public static int Sort(RNum a,RNum b)
                {
                    if (a.IsNum && b.IsNum)
                    {
                        if (a.P == string.Empty) return SortPos;
                        if (b.P == string.Empty) return -SortPos;
                        if (a.P.Length != b.P.Length) return SortPos * (a.P.Length - b.P.Length);
                        return SortPos * (a.P[0] - b.P[0]);
                    }
                    if (!a.IsNum && !b.IsNum) return SortPos * (a.Lenth - b.Lenth);
                    if (a.IsNum) return SortPos;
                    return -SortPos;
                }
                public static int Sort(Item a,Item b)
                {
                    List<RNum> ar = new List<RNum>(a.powers.Values);
                    List<RNum> br = new List<RNum>(b.powers.Values);
                    HPAQNum at = HPAQNum.Zero;
                    HPAQNum bt = HPAQNum.Zero;
                    foreach (RNum x in ar)
                        at += x.Num == HPAQNum.Null ?new HPAQNum( x.Lenth) : x.Num;
                    foreach (RNum x in br)
                        bt += x.Num == HPAQNum.Null ? new HPAQNum(x.Lenth) : x.Num;
                    at -= bt;
                    return at == HPAQNum.Zero ? 0 : (at.pos ? -SortPos : SortPos);
                }
            }
            
        }
        public enum Notes
        {
            Empty,
            Down,
            Power,
            Add,
            Minus,
            Multiply,
            Sqrt,
            Func
        }
        public static string NotesToString(Notes note)
        {
            switch (note)
            {
                case Notes.Add:
                    return "+";
                case Notes.Down:
                    return "/";
                case Notes.Empty:
                    return "_";
                case Notes.Minus:
                    return "-";
                case Notes.Multiply:
                    return "*";
                case Notes.Power:
                    return "^";
                case Notes.Sqrt:
                    return "$";
                case Notes.Func:
                    return "#";
            }
            return "?";
        }
        public class CNum
        {
            public double Re, Im;
            public static CNum One = new CNum(1, 0),I=new CNum(0,1);
            public CNum(double re, double im)
            {
                Re = re;
                Im = im;
            }
            public static CNum FromLA(double len, double arg) => new CNum(len * Math.Cos(arg), len * Math.Sin(arg));
            public double Arg
            {
                get=> Math.Atan2(Im, Re);
            }
            public double Len
            {
                get => Math.Sqrt(Re * Re + Im * Im);
            }
            public CNum Congj
            {
                get => new CNum(Re, -Im);
            }
            public override string ToString()
            {
                string r = "";
                if (Re != 0) r += Re.ToString();
                if (Im > 0) r += "+";
                if (Im != 0) r += Im.ToString() + "i";
                return r;
            }
            public static CNum operator +(CNum a, CNum b) => new CNum(a.Re + b.Re, a.Im + b.Im);
            public static CNum operator -(CNum a, CNum b) => new CNum(a.Re - b.Re, a.Im - b.Im);
            public static CNum operator *(CNum a, CNum b) => new CNum(a.Re * b.Re - a.Im * b.Im, a.Re * b.Im + a.Im * b.Re);
            public static CNum operator /(CNum a, CNum b)
            {
                double t = b.Re * b.Re + b.Im * b.Im;
                return new CNum((a.Re * b.Re + a.Im * b.Im) / t, (a.Im * b.Re - a.Re * b.Im) / t);
            }
            public static CNum operator ^(CNum an, int bn)
            {
                if (bn < 0) throw new Exception("HPA ^ power<0");
                CNum re = an;
                CNum temp2 = new CNum(1,0);
                while (bn > 1)
                {
                    if (bn % 2 == 0)
                    {
                        re *= re;
                        bn /= 2;
                    }
                    else
                    {
                        temp2 *= re;
                        bn -= 1;
                    }
                }
                return re * temp2;
            }
            public static bool operator ==(CNum a, CNum b) => a.Re == b.Re && a.Im == b.Im;
            public static bool operator !=(CNum a, CNum b) => !(a == b);
            public static CNum Exp(CNum x)
            {
                return CNum.FromLA(Math.Exp(x.Re), x.Im);
            }
            public static CNum Power(CNum a,CNum b)
            {
                return Exp(b * Ln(a));
            }
            public static CNum Ln(CNum x)
            {
                return new CNum(Math.Log(x.Len), x.Arg);
            }
            public static CNum Sin(CNum x)
            {
                double em = Math.Exp(x.Im), en = Math.Exp(-x.Im);
                return new CNum((em + en) * Math.Sin(x.Re) / 2.0, (em - en) * Math.Cos(x.Re) / 2.0);
            }
            public static CNum Cos(CNum x)
            {
                double em = Math.Exp(x.Im), en = Math.Exp(-x.Im);
                return new CNum((em + en) * Math.Cos(x.Re) / 2.0, (en - em) * Math.Sin(x.Re) / 2.0);
            }
            public static CNum Tan(CNum x) => Sin(x) / Cos(x);
            public static List<CNum> ASin(CNum x)
            {
                List<CNum> a = Ln(Add(new List<CNum>() { new CNum(-x.Im, x.Re) }, Sqrt(One - (x ^ 2), 2)));
                for(int i = 0; i < a.Count; i++)
                {
                    double t = a[i].Im;
                    a[i].Im = -a[i].Re;
                    a[i].Re = t;
                }
                return a;
            }
            public static List<CNum> ACos(CNum x)
            {
                List<CNum> a = Ln(Add(new List<CNum>() { x }, Multi( Sqrt(One - (x ^ 2), 2),new List<CNum>() {I })));
                for (int i = 0; i < a.Count; i++)
                {
                    double t = a[i].Im;
                    a[i].Im = -a[i].Re;
                    a[i].Re = t;
                }
                return a;
            }
            public static CNum ATan(CNum x) => Ln((I - x) / (I + x)) / (new CNum(0,2));
            public static CNum Sinh(CNum x)
            {
                double em = Math.Exp(x.Re), en = Math.Exp(-x.Re);
                return new CNum((em - en) * Math.Cos(x.Im) / 2.0, (em + en) * Math.Sin(x.Im) / 2.0);
            }
            public static CNum Cosh(CNum x)
            {
                double em = Math.Exp(x.Re), en = Math.Exp(-x.Re);
                return new CNum((em+en)*Math.Cos(x.Im)/2.0,(em-en)*Math.Sin(x.Im)/2.0);
            }
            public static CNum Tanh(CNum x) => Sinh(x) / Cosh(x);
            public static List<CNum> Tanh(List<CNum> x)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum z in x)
                    re.Add(Sinh(z) / Cosh(z));
                return re;
            }
            public static List<CNum> Coj(List<CNum> x)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum z in x)
                    re.Add(z.Congj);
                return re;
            }
            public static List<CNum> Cosh(List<CNum> x)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum z in x)
                    re.Add(Cosh(z));
                return re;
            }
            public static List<CNum> Sinh(List<CNum> x)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum z in x)
                    re.Add(Sinh(z));
                return re;
            }

            public static List<CNum> ACos(List<CNum> x)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum c in x)
                    re.AddRange(ACos(c));
                return re;
            }
            public static List<CNum> ASin(List<CNum> x)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum c in x)
                    re.AddRange(ASin(c));
                return re;
            }
            public static List<CNum> ATan(List<CNum> x)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum z in x)
                    re.Add(ATan(z));
                return re;
            }
            public static List<CNum> Tan(List<CNum> x)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum z in x)
                    re.Add(Sin(z)/Cos(z));
                return re;
            }
            public static List<CNum> Cos(List<CNum> x)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum z in x)
                    re.Add(Cos(z));
                return re;
            }
            public static List<CNum> Sin(List<CNum> x)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum z in x)
                    re.Add(Sin(z));
                return re;
            }
            public static List<CNum> Ln(List<CNum> x)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum z in x)
                    re.Add(Ln(z));
                return re;
            }
            public static List<CNum> Exp(List<CNum> x)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum z in x)
                    re.Add(Exp(z));
                return re;
            }
            public static List<CNum> Abs(List<CNum> x)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum z in x)
                    re.Add(new CNum(z.Len,0));
                return re;
            }
            public static List<CNum> Sqrt(CNum x, int n)
            {
                double l = Math.Pow(x.Len, 1.0 / n), c=x.Arg, kp = 2*Math.PI/n;
                List<CNum> re = new List<CNum>();
                re.Add(FromLA(l, c));
                for(int k = 1; k < n; k++)
                {
                    c += kp;
                    re.Add(FromLA(l, c));
                }
                return re;
            }
            public static List<CNum> Sqrt(List<CNum> x, List<CNum> n)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum c in x)
                    foreach(CNum y in n)
                        re.AddRange(Sqrt(c, (int)y.Re));
                return re;
            }
            public static List<CNum> Add(List<CNum> a,List<CNum> b)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum x in a)
                    foreach (CNum y in b)
                        re.Add(x + y);
                return re;
            }
            public static List<CNum> Minus(List<CNum> a, List<CNum> b)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum x in a)
                    foreach (CNum y in b)
                        re.Add(x - y);
                return re;
            }
            public static List<CNum> Multi(List<CNum> a, List<CNum> b)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum x in a)
                    foreach (CNum y in b)
                        re.Add(x * y);
                return re;
            }
            public static List<CNum> Div(List<CNum> a, List<CNum> b)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum x in a)
                    foreach (CNum y in b)
                        re.Add(x / y);
                return re;
            }
            public static List<CNum> Power(List<CNum> a, List<CNum> b)
            {
                List<CNum> re = new List<CNum>();
                foreach (CNum x in a)
                    foreach (CNum y in b)
                        re.Add(Power(x,y));
                return re;
            }
            public static string ListToString(List<CNum> l)
            {
                string s = "[ " + l[0].ToString();
                for (int i = 1; i < l.Count; i++)
                    s += ", " + l[i].ToString();
                return s + "]";
            }
            public PointF ToPoint() => new PointF((float)Re, (float)Im);
            
        }
        public class CNumF
        {
            public Notes note;//power: ^(Re/Im)
            public CNumF A, B;
            public CNum cNum;
            public string para;
            public bool isNum
            {
                get => (!Equals(cNum,null))&& para == string.Empty;
            }
            public bool isPara
            {
                get => para!=string.Empty;
            }
            public bool isF
            {
                get => !Equals(A, null) && !Equals(B, null);
            }
            public CNumF(CNumF a, CNumF b, Notes note)
            {
                this.note = note;
                A = a;
                B = b;
                para = string.Empty;
            }
            public CNumF(CNum a)
            {
                note = Notes.Empty;
                cNum = a;
                para = string.Empty;
            }
            public CNumF(string s)
            {
                if (s[s.Length - 1] == 'i')
                {
                    cNum = new CNum(0, s.Length > 1 ? Convert.ToDouble(s.Substring(0, s.Length - 1)) : 1);
                    para = string.Empty;
                }
                else
                {
                    int i = s.Length;
                    while (i-- > 0 && IsUnkNum(s[i])) ;
                    if (i != s.Length - 1)
                    {
                        
                        para = s.Substring(i + 1);
                        if (i == 0)
                        {
                            if (s[0] == '-') { cNum = new CNum(-1,0); return; }
                            if (s[0] == '+') { cNum = new CNum(1,0); return; }
                        }
                        cNum = new CNum(i == -1 ? 1 : Convert.ToDouble(s.Substring(0, i + 1)), 0);
                    }
                    else
                    {
                        para = string.Empty;
                        cNum = new CNum(Convert.ToDouble(s), 0);
                    }
                }


            }
            private static CNumF ToCNumWK(string s)
            {
                if (s.Length == 1)
                {
                    if (s == "+") return new CNumF(new CNum(1,0));
                    if (s == "-") return new CNumF(new CNum(1, 0));
                    return new CNumF(s);
                }
                int i = s.IndexOf('(');
                if (i != -1)
                {
                    int k = MatchKuo(s, i);
                    if (i == 0 && k == s.Length - 1) return ToCNumWK(s.Substring(1, s.Length - 2));
                }
                i = IndexOfWD(s, '+', 0);
                if (i != -1 && i != 0) return new CNumF(ToCNumWK(s.Substring(0, i)), ToCNumWK(s.Substring(i + 1)), Notes.Add);
                i = LastIndexOfWD(s, '-', 0);
                if (i != -1 && i != 0) return new CNumF(ToCNumWK(s.Substring(0, i)), ToCNumWK(s.Substring(i + 1)), Notes.Minus);
                i = LastIndexOfWD(s, '*', 0);
                if (i != -1) return new CNumF(ToCNumWK(s.Substring(0, i)), ToCNumWK(s.Substring(i + 1)), Notes.Multiply);
                i = LastIndexOfWD(s, '/', 0);
                if (i != -1) return new CNumF(ToCNumWK(s.Substring(0, i)), ToCNumWK(s.Substring(i + 1)), Notes.Down);
                i = IndexOfWD(s, '^', 0);
                if (i != -1) return new CNumF(ToCNumWK(s.Substring(0, i)), ToCNumWK(s.Substring(i + 1)), Notes.Power);
                i = IndexOfWD(s, '$', 0);
                if (i != -1) return new CNumF(ToCNumWK(s.Substring(0, i)), ToCNumWK(s.Substring(i + 1)), Notes.Sqrt);
                i = IndexOfWD(s, '#', 0);
                if (i != -1) return new CNumF(ToCNumWK(s.Substring(0, i)), ToCNumWK(s.Substring(i + 1)), Notes.Func);
                return new CNumF(s);

            }
            public static CNumF ToCNumWP(string s)
            {
                int i = 1;
                while (i < s.Length)
                {
                    if (!IsAlpha(s[i]))
                    {
                        if (s[i] == '(' && !IsNote(s[i - 1]) && s[i - 1] != '(' && s[i - 1] != ')')
                            s = s.Insert(i++, "#");
                        else if (s[i] == '(' && s[i - 1] == ')')
                            s = s.Insert(i++, "*");
                        else if (s[i] == ')' && i < s.Length - 1 && !IsNote(s[i + 1]) && s[i + 1] != '(' && s[i + 1] != ')')
                            s = s.Insert(++i, "*");
                        else if (s[i] != '(' && s[i] != ')' && !IsNote(s[i]) && IsAlpha(s[i - 1]))
                            s = s.Insert(i++, "*");
                        else if (!IsNote(s[i]) && s[i] != '(' && s[i] != ')' && s[i - 1] == '-')
                        {
                            s = s.Insert(i, "1*");
                            i += 2;
                        }
                    }
                    i += 1;//(x^2+(a-2)(a-4))/((x^2+(a-2)^2)(x^2+(a-4)^2))
                }
                return ToCNumWK(s);
            }
            public void Simpilify()
            {
                if (isF)
                {
                    A.Simpilify();
                    B.Simpilify();
                    if (A.isNum && B.isNum)
                    {
                        switch (note)
                        {
                            case Notes.Add:
                                cNum = A.cNum + B.cNum;break;
                            case Notes.Down:
                                cNum = A.cNum / B.cNum; break;
                            case Notes.Minus:
                                cNum = A.cNum - B.cNum; break;
                            case Notes.Multiply:
                                cNum = A.cNum * B.cNum; break;
                            case Notes.Power:
                                cNum = A.cNum^(int)B.cNum.Re; break;
                        }
                        if (note != Notes.Sqrt)
                        {
                            A = null;
                            B = null;
                        }
                    }
                }
                else if (Consts.ContainsKey(para))
                {
                    cNum = new CNum(Consts[para],0);
                    para = string.Empty;
                }
            }
            public static List<CNum> MultiNFunc(CNumF A, CNumF B, Dictionary<string, CNum> z)
            {
                List<CNum> b = B.Compute(z);
                if (A.isPara)
                {
                    switch (A.para)
                    {
                        case "sin":
                            return CNum.Sin(b);
                        case "cos":
                            return CNum.Cos(b);
                        case "tan":
                            return CNum.Tan(b);
                        case "ln":
                            return CNum.Ln(b);
                        case "sinh":
                            return CNum.Sinh(b);
                        case "cosh":
                            return CNum.Cosh(b);
                        case "tanh":
                            return CNum.Tanh(b);
                        case "abs":
                            return CNum.Abs(b);
                        case "asin":
                            return CNum.ASin(b);
                        case "acos":
                            return CNum.ACos(b);
                        case "atan":
                            return CNum.ATan(b);
                        case "exp":
                            return CNum.Exp(b);
                        case "coj":
                            return CNum.Coj(b);
                    }
                }
                return CNum.Multi( A.Compute(z) , b);
            }
            public List<CNum> Compute(Dictionary<string, CNum> z)
            {
                if (isPara) return new List<CNum>() { z[para]*cNum };
                if (isNum) return new List<CNum>() { cNum };
                switch (note)
                {
                    case Notes.Add:
                        return CNum.Add(A.Compute(z), B.Compute(z));
                    case Notes.Down:
                        return CNum.Div(A.Compute(z), B.Compute(z));
                    case Notes.Minus:
                        return CNum.Minus(A.Compute(z), B.Compute(z));
                    case Notes.Multiply:
                        return CNum.Multi(A.Compute(z), B.Compute(z));
                    case Notes.Power:
                        return CNum.Power(A.Compute(z), B.Compute(z));
                    case Notes.Sqrt:
                        return CNum.Sqrt(A.Compute(z), B.Compute(z));
                    case Notes.Func:
                        return MultiNFunc(A, B, z);
                }
                throw new Exception("CNumF Compute ERROR!");
            }
            public override string ToString()
            {
                if (isPara) return para;
                if (isNum) return cNum.ToString();
                return "(" + A.ToString() + ")" + NotesToString(note) + "(" + B.ToString() + ")";
            }
        }
        public class Function
        {
            public Notes note;//power: ^(Re/Im)
            public Function A, B;
            public double num;
            public string para;
            public bool isF
            {
                get => !Equals(A, null) && !Equals(B, null);
            }
            public bool isNum
            {
                get => !isF && para==string .Empty;
            }
            public bool isPara
            {
                get => para != string.Empty;
            }
            public Function(Function a, Function b, Notes note)
            {
                this.note = note;
                A = a;
                B = b;
                para = string.Empty;
            }
            public Function(double a)
            {
                note = Notes.Empty;
                num = a;
                para = string.Empty;
            }
            public Function(string s)
            {
                if (s.Length == 1 && !IsAlpha(s[0]))
                {
                    if (IsUnkNum(s[0]))
                    {
                        num = 1;
                        para = s;
                        return;
                    }
                    throw new Exception("Function Format ERROR!");
                }
                int i = s.Length;
                while (i-- > 0 && IsUnkNum(s[i])) ;
                if (i != s.Length - 1)
                {
                    para = s.Substring(i + 1);
                    if (i == 0)
                    {
                        if (s[0] == '-') { num = -1; return; }
                        if (s[0] == '+') { num = 1; return; }
                    }
                    num = i == -1 ? 1 : Convert.ToDouble(s.Substring(0, i + 1));
                }
                else 
                {
                    para = string.Empty;
                    num = Convert.ToDouble(s); 
                }

            }
            private static Function ToFuncWK(string s)
            {
                if (s.Length == 1)
                {
                    if (s == "+") return new Function(1);
                    if (s == "-") return new Function(1);
                    return new Function(s);
                }
                int i = s.IndexOf('(');
                if (i != -1)
                {
                    int k = MatchKuo(s, i);
                    if (i == 0 && k == s.Length - 1) return ToFuncWK(s.Substring(1, s.Length - 2));
                }
                i = IndexOfWD(s, '+', 0);
                if (i != -1 && i != 0) return new Function(ToFuncWK(s.Substring(0, i)), ToFuncWK(s.Substring(i + 1)), Notes.Add);
                i = LastIndexOfWD(s, '-', 0);
                if (i != -1 && i != 0) return new Function(ToFuncWK(s.Substring(0, i)), ToFuncWK(s.Substring(i + 1)), Notes.Minus);
                i = LastIndexOfWD(s, '*', 0);
                if (i != -1) return new Function(ToFuncWK(s.Substring(0, i)), ToFuncWK(s.Substring(i + 1)), Notes.Multiply);
                i = LastIndexOfWD(s, '/', 0);
                if (i != -1) return new Function(ToFuncWK(s.Substring(0, i)), ToFuncWK(s.Substring(i + 1)), Notes.Down);
                i = IndexOfWD(s, '^', 0);
                if (i != -1) return new Function(ToFuncWK(s.Substring(0, i)), ToFuncWK(s.Substring(i + 1)), Notes.Power);
                i = IndexOfWD(s, '$', 0);
                if (i != -1) return new Function(ToFuncWK(s.Substring(0, i)), ToFuncWK(s.Substring(i + 1)), Notes.Sqrt);
                i = IndexOfWD(s, '#', 0);
                if (i != -1) return new Function(ToFuncWK(s.Substring(0, i)), ToFuncWK(s.Substring(i + 1)), Notes.Func);
                return new Function(s);

            }
            public static Function ToFunctionWP(string s)
            {
                int i = 1;
                while (i < s.Length)
                {
                    if (!IsAlpha(s[i]))
                    {
                        if (s[i] == '(' && !IsNote(s[i - 1]) && s[i - 1] != '(' && s[i - 1] != ')')
                            s = s.Insert(i++, "#");
                        else if (s[i] == '(' && s[i - 1] == ')')
                            s = s.Insert(i++, "*");
                        else if (s[i] == ')' && i < s.Length - 1 && !IsNote(s[i + 1]) && s[i + 1] != '(' && s[i + 1] != ')')
                            s = s.Insert(++i, "*");
                        else if (s[i] != '(' && s[i] != ')' && !IsNote(s[i]) && IsAlpha(s[i - 1]))
                            s = s.Insert(i++, "*");
                        else if (s[i] == '(' && s[i - 1] == '-')
                        {
                            s = s.Insert(i, "1*");
                            i += 2;
                        }
                    }
                    i += 1;//(x^2+(a-2)(a-4))/((x^2+(a-2)^2)(x^2+(a-4)^2))
                }
                return ToFuncWK(s);
            }
            
            public void Simpilify()
            {
                if (isF)
                {
                    A.Simpilify();
                    B.Simpilify();
                    if (A.isNum && B.isNum)
                    {
                        switch (note)
                        {
                            case Notes.Add:
                                num = A.num + B.num; break;
                            case Notes.Down:
                                num = A.num / B.num; break;
                            case Notes.Minus:
                                num = A.num - B.num; break;
                            case Notes.Multiply:
                                num = A.num * B.num; break;
                            case Notes.Power:
                                num = Math.Pow(A.num,B.num); break;
                        }
                        if (note != Notes.Sqrt)
                        {
                            A = null;
                            B = null;
                        }
                    }
                }
                else if (Consts.ContainsKey(para))
                {
                    num = Consts[para];
                    para = string.Empty;
                }
            }
            public static double  MultiNFunc(Function A, Function B, Dictionary<string, double> z)
            {
                double b = B.Compute(z);
                if (A.isPara)
                {
                    switch (A.para)
                    {
                        case "sin":
                            return Math.Sin(b);
                        case "cos":
                            return Math.Cos(b);
                        case "tan":
                            return Math.Tan(b);
                        case "ln":
                            return Math.Log(b);
                        case "log":
                            return Math.Log10(b);
                        case "sinh":
                            return Math.Sinh(b);
                        case "cosh":
                            return Math.Cosh(b);
                        case "tanh":
                            return Math.Tanh(b);
                        case "abs":
                            return Math.Abs(b);
                        case "asin":
                            return Math.Asin(b);
                        case "acos":
                            return Math.Acos(b);
                        case "atan":
                            return Math.Atan(b);
                        case "exp":
                            return Math.Exp(b);
                        case "floor":
                            return Math.Floor(b);
                        case "ceiling":
                            return Math.Ceiling(b);
                    }
                }
                return A.Compute(z) * b;
            }
            public double Compute(Dictionary<string,double> z)
            {
                if (isPara) return z[para]*num;
                if(isF)
                switch (note)
                {
                    case Notes.Add:
                        return A.Compute(z)+ B.Compute(z);
                    case Notes.Down:
                        return A.Compute(z) / B.Compute(z);
                    case Notes.Minus:
                        return A.Compute(z) - B.Compute(z);
                    case Notes.Multiply:
                        return A.Compute(z) * B.Compute(z);
                        case Notes.Power:
                        return Math.Pow(A.Compute(z), B.Compute(z));
                    case Notes.Sqrt:
                        return Math.Pow(A.Compute(z), 1/B.Compute(z));
                    case Notes.Func:
                        return MultiNFunc(A, B, z);
                    }
                return num;
            }
            public override string ToString()
            {
                if (isPara) return para.ToString();
                if (isNum) return num.ToString();
                return "(" + A.ToString() + ")" + NotesToString(note) + "(" + B.ToString() + ")";
            }
        }
        public class RNumEquation
        {
            public RNum Left;
            public RNum Right;
            public List<RNum> Downs;
            public RNumEquation.Notes Note;
            public static int AccuracyOfSolve = 40;
            public RNumEquation(RNum left, RNum right, RNumEquation.Notes note)
            {
                Left = left;
                Right = right;
                Note = note;
            }
            public RNumEquation(RNumEquation rNumEquation)
            {
                Left = new RNum(rNumEquation.Left);
                Right = new RNum(rNumEquation.Right);
                Note = rNumEquation.Note;
            }
            public RNumEquation(string s)
            {
                int i = s.IndexOf('!');
                if (i != -1)
                {
                    Note = RNumEquation.Notes.Not;
                }
                else Note = RNumEquation.Notes.Empty;
                i = s.IndexOf('=');
                if (i != -1)
                {
                    Note |= RNumEquation.Notes.EqualTo;
                    if (s[i - 1] == '>') Note |= RNumEquation.Notes.MoreThen;
                    else if (s[i - 1] == '<') Note |= RNumEquation.Notes.LessThan;
                    Left = RNum.ToRNumWP(s.Substring(0, Note != RNumEquation.Notes.EqualTo ? i - 1 : i));
                    Right = RNum.ToRNumWP(s.Substring(i + 1));
                    return;
                }
                i = s.IndexOf('<');
                if (i != -1)
                {
                    Note |= RNumEquation.Notes.LessThan;
                    Left = RNum.ToRNumWP(s.Substring(0, Note != RNumEquation.Notes.LessThan ? i - 1 : i));
                    Right = RNum.ToRNumWP(s.Substring(i + 1));
                    return;
                }
                i = s.IndexOf('>');
                if (i != -1)
                {
                    Note |= RNumEquation.Notes.MoreThen;
                    Left = RNum.ToRNumWP(s.Substring(0, Note != RNumEquation.Notes.MoreThen ? i - 1 : i));
                    Right = RNum.ToRNumWP(s.Substring(i + 1));
                    return;
                }
                throw new Exception("Equation No Note!");
            }
            public void Simpify()
            {
                while (!Right.IsNum)
                {
                    switch (Right.Note)
                    {
                        case MathEX.Notes.Add:
                            Left -= Right.B;
                            break;
                        case MathEX.Notes.Down:
                            Left *= Right.B;
                            break;
                        case MathEX.Notes.Minus:
                            Left += Right.B;
                            break;
                        case MathEX.Notes.Multiply:
                            Left /= Right.B;
                            break;
                        case MathEX.Notes.Power:
                            if (Right.B.Note == MathEX.Notes.Down)
                            {
                                RNum t = Right.B.A;
                                Right.B.A = Right.B.B;
                                Right.B.B = t;
                            }
                            else Right.B = new RNum(RNum.One) / Right.B;
                            Left ^= Right.B;
                            break;
                    }
                    Right = Right.A;
                }
                if (Right != RNum.Zero)
                {
                    Left -= Right;
                    Right = new RNum(RNum.Zero);
                }
                Left.Simpify();
                Downs = Left.GetDownS();
                int i=0, j;
                while (i < Downs.Count)
                {
                    j = i + 1;
                    while (j < Downs.Count)
                    {
                        if (Downs[i] == Downs[j])
                            Downs.RemoveAt(j);
                        else j += 1;
                    }
                    i += 1;
                }
                foreach (RNum x in Downs)
                    Left *= new RNum(x);
                Left.Simpify();
            }
            public HPAQNum Solve(HPAQNum start,string x)
            {
                if ((Note & (RNumEquation.Notes.LessThan | RNumEquation.Notes.MoreThen)) != 0) throw new Exception();
                List<string> ps = Left.GetPs();
                List<string> temp = Right.GetPs();
                foreach (string s in temp)
                    if (!ps.Contains(s)) ps.Add(s);
                ps.Remove(x);
                RNum target;
                if (ps.Count == 0)
                {
                    RNumEquation temp3 = new RNumEquation(this);
                    temp3.Simpify();
                    target = temp3.Left;
                }
                else
                {
                    Dictionary<string, HPAQNum> temp2 = new Dictionary<string, HPAQNum>();
                    foreach (string s in ps)
                        temp2[s] = start;
                    RNumEquation temp3 = new RNumEquation(this);
                    temp3.Simpify();
                    temp3.Left.Replace(temp2);
                    target = temp3.Left;
                }
                RNum temp4 = new RNum(target);
                temp4.Derivation(x);
                target /= temp4;
                target = new RNum(new HPAQNum(HPAQNum.One), x) - target;
                target.Simpify();
                Dictionary<string, HPAQNum> dt = new Dictionary<string, HPAQNum> { [x] = start };
                HPAQNum t,t2=HPAQNum.Null;
                while (true)
                {
                    dt[x] =target.Compute(dt);
                    dt[x].Simpify();
                    dt[x].LimitTo(256);
                    //Console.WriteLine(dt[x].Value);
                    t = start - dt[x];
                    if ((t.Down.Len>t.Up.Len&& t.Down.Len-t.Up.Len > AccuracyOfSolve)||t==HPAQNum.Zero) break;
                    if (t2.Equals(HPAQNum.Null)) t2 = t;
                    else if (t2 == t) return new HPAQNum(HPAQNum.Null);
                    start = dt[x];
                }
                return dt[x];
            }
            public enum Notes
            {
                Empty=0,
                EqualTo=1,
                LessThan=2,
                MoreThen=4,
                Not=8
            }
            public override string ToString()
            {
                string note = "";
                if ((Note & Notes.Not) != 0) note += "!";
                if ((Note & Notes.LessThan) != 0) note += "<";
                if ((Note & Notes.MoreThen) != 0) note += ">";
                if ((Note & Notes.EqualTo) != 0) note += "=";
                return Left.ToString() + note + Right.ToString();
            }
            public MultinomialEX ToMultinoal()
            {
                Simpify();
                return Left.ToMultinoal();
            }
            public static RNumEquation operator +(RNumEquation a, RNumEquation b) => new RNumEquation(a.Left + b.Left, a.Right + b.Right, a.Note | b.Note);
            public static RNumEquation operator -(RNumEquation a, RNumEquation b) => new RNumEquation(a.Left - b.Left, a.Right - b.Right, a.Note | b.Note);
            public static RNumEquation operator *(RNumEquation a, RNumEquation b) => new RNumEquation(a.Left * b.Left, a.Right * b.Right, a.Note | b.Note);
            public static RNumEquation operator /(RNumEquation a, RNumEquation b) => new RNumEquation(a.Left / b.Left, a.Right / b.Right, a.Note | b.Note);
            public static RNumEquation operator ^(RNumEquation a, RNumEquation b) => new RNumEquation(a.Left ^ b.Left, a.Right ^ b.Right, a.Note | b.Note);
        }
        public class RNumRecursion
        {
            public RNum Mul;
            public string x;
            public RNumRecursion(RNum n)
            {
                List<string> ps = n.GetPs();
                if (ps.Count > 1) throw new Exception("Recursion array has too much parameters.");
                if (ps.Count == 0) x = string.Empty;
                else x = ps[0];
                Mul = n;
            }
            public HPAQNum Compute(HPAQNum start,int n)
            {
                Dictionary<string, HPAQNum> Values = new Dictionary<string, HPAQNum>();
                while (n > 0)
                {
                    if (x != string.Empty) Values[x] = start;
                    start = Mul.Compute(Values);
                    n -= 1;
                }
                return start;
            }
        }
        public class RNumConsole
        {
            public Dictionary<string, RNum> Values;
            public static string Front = ">>";
            public const string Text = "Advenced calculator V9.1.0\nCopyright Rick_T 2020.4.12\nUse \"dir\" for codelist.\n";
            private RNum ans;
            public RNumConsole()
            {
                Values = new Dictionary<string, RNum>();
                ans = new RNum(RNum.Zero);
            }
            public void StartConsole()
            {
                Console.WriteLine(Text);
                while (true)
                {
                    Console.Write(Front);
                    Console.WriteLine(GetIn(Console.ReadLine()));
                }
            }
            public string GetIn(string s)
            {
                try
                {
                    s = RemoveBlank(s);
                }
                catch (Exception e)
                {
                    return "ERROR: " + e.Message + ":\"" + s + "\".";
                }
                int i = s.IndexOf(' ');
                if (i != -1)
                {
                    string code = s.Substring(0, i);
                    s = s.Substring(i + 1);
                    string[] ps = s.Split(' ');
                    return Do(code, ps);
                }
                if (s == "dir") return DirList;
                return Do("", new string[] { s });
            }
            public string Do(string Code, string[] para)
            {
                Code = Code.ToLower();
                try
                {
                    switch (Code)
                    {
                        case "":
                            RNum t = GetValue(para[0]);
                            ans = t;
                            return t.ToString();
                        case "replace":
                            if (para.Length != 3) throw new NotEnoughParameterExpection(Code);
                            RNum a = GetValue(para[0]);
                            RNum b = GetValue(para[1]);
                            RNum c = GetValue(para[2]);
                            a.Replace(new Dictionary<RNum, RNum> { [b] = c });
                            a.Simpify();
                            ans = a;
                            return a.ToString();
                        case "solve":
                            if (para.Length != 1) throw new NotEnoughParameterExpection(Code);
                            RNum d = GetValue(para[0]);
                            List<string> ps = d.GetPs();
                            if (ps.Count == 0) return "No answer!";
                            RNumEquation eq = new RNumEquation(d, new RNum(RNum.Zero), MathEX.RNumEquation.Notes.EqualTo);
                            HPAQNum answer = eq.Solve(HPAQNum.One, ps[0]);
                            ans = new RNum(answer);
                            return ps[0] + " = " + answer.Value;
                        case "compute":
                            if (para.Length != 1) throw new NotEnoughParameterExpection(Code);
                            RNum c1 = GetValue(para[0]);
                            List<string> ps2 = c1.GetPs();
                            Dictionary<string, RNum> d1 = new Dictionary<string, RNum>();
                            foreach (string x in ps2)
                            {
                                Console.Write(x + "=");
                                d1[x] = GetValue(Console.ReadLine());
                            }
                            c1.Replace(d1);
                            c1.Simpify();
                            ans = c1;
                            return c1.ToString();
                        case "deriv":
                            if (para.Length != 2) throw new NotEnoughParameterExpection(Code);
                            RNum c2 = GetValue(para[0]);
                            c2.Derivation(para[1]);
                            ans = c2;
                            return c2.ToString();
                        case "to":
                            if (para.Length != 2) throw new NotEnoughParameterExpection(Code);
                            RNum t1 = GetValue(para[0]);
                            RNum t2 = GetValue(para[1]);
                            t1 = t1.AdsorbRNum(t2);
                            ans = t1;
                            return t1.ToString();
                        case "simpify":
                            if (para.Length != 1) throw new NotEnoughParameterExpection(Code);
                            RNum s1 = GetValue(para[0]);
                            s1.Simpify();
                            ans = s1;
                            return s1.ToString();
                        case "recu":
                            if (para.Length != 3) throw new NotEnoughParameterExpection(Code);
                            RNum r1 = GetValue(para[0]);
                            HPAQNum r2 = HPAQNum.ToHPAQNumWP(para[1]);
                            int n = ToIntWP(para[2]);
                            RNumRecursion r3 = new RNumRecursion(new RNum(r1));
                            HPAQNum re1 = r3.Compute(r2, n);
                            ans = new RNum(re1);
                            return re1.ToString();
                        case "value":
                            if (para.Length != 1) throw new NotEnoughParameterExpection(Code);
                            HPAQNum v1 = HPAQNum.ToHPAQNumWP(para[0]);
                            ans = new RNum(v1);
                            return v1.Value;
                        case "fact":
                            if (para.Length != 1) throw new NotEnoughParameterExpection(Code);
                            Multinomial m1 = new Multinomial(para[0]);
                            return Multinomial.MultionalsListString(m1.Factorization());
                        case "lag":
                            List<PointS> pos = new List<PointS>();
                            for (int i = 0; i < para.Length; i++)
                                pos.Add(new PointS(para[i]));
                            Multinomial re2 = Multinomial.Lagrange(pos);
                            string tr1 = re2.ToString();
                            ans = RNum.ToRNumWP(tr1);
                            return tr1;
                        case "tri":
                            if (para.Length != 3) throw new NotEnoughParameterExpection(Code);
                            QNum q1 = QNum.ToQNumWP(para[0]);
                            QNum q2 = QNum.ToQNumWP(para[1]);
                            QNum q3 = QNum.ToQNumWP(para[2]);
                            Triangle at = new Triangle(q1, q2, q3);
                            return at.GetAllInf();
                        default:
                            if (para.Length != 1) throw new NotEnoughParameterExpection(Code);
                            Values[Code] = RNum.ToRNumWP(para[0]);
                            ans = Values[Code];
                            return Code + " = " + Values[Code];
                    }
                }
                catch (Exception e)
                {
                    return e.ToString();
                }

            }
            public const string DirList = "replace,solve,deriv,fact,lag,tri,dir,value,recu,simpify,to,compute";
            public RNum GetValue(string s)
            {
                if (s == "ans") return ans;
                if (Values.ContainsKey(s)) return Values[s];
                return RNum.ToRNumWP(s);
            }
            public class NotEnoughParameterExpection : Exception
            {
                private string usage;
                public NotEnoughParameterExpection(string code) : base("ERROR:Don't have enough parameters: "+code)
                {
                    switch (code)
                    {
                        case "replace":
                            usage = "replace source [sign] [RNum]";
                            return;
                        case "solve":
                            usage = "solve [RNum]";
                            return;
                        case "compute":
                            usage = "compute [RNum]";
                            return;
                        case "deriv":
                            usage = "deriv [RNum] [element]";
                            return;
                        case "to":
                            usage = "to [RNum1] [RNum2]";
                            return;
                        case "simpify":
                            usage = "simpfy [RNum]";
                            return;
                        case "recu":
                            usage = "recu [RNum] [QNum] [Int]";
                            return;
                        case "value":
                            usage = "value [QNum]";
                            return;
                        case "fact":
                            usage = "fact [Multinoal]";
                            return;
                        case "lag":
                            usage = "lag [Point]...";
                            return;
                        case "tri":
                            usage = "tri [QNum] [QNum] [QNum]";
                            return;
                        default:
                            usage = "Can't find code :( \"" + code + "\"";
                            return;
                    }
                }
                public override string ToString()
                {
                    return Message+"\nUsage:"+usage;
                }
            }
            public string RemoveBlank(string s)
            {
                int i = 0, j = s.Length - 1;
                while (i < s.Length && s[i] == ' ') i += 1;
                while (j >= 0 && s[j] == ' ') j -= 1;
                if (j + 1 - i <= 0) throw new Exception("You input Nothing!");
                if (j + 1 - i == s.Length) return s;
                return s.Substring(i, j + 1 - i);
            }
        }
        public class Graph
        {
            public class Line
            {
                public int[] points;
                public int length;
                public Line(int a,int b, int length = 1)
                {
                    points = new int[] { a, b };
                    this.length = length;
                }
                public Line(Line l)
                {
                    points = new int[] { l.points[0], l.points[1] };
                    length = l.length;
                }
                public void Replace(int source, int target)
                {
                    for (int i = 0; i < 2; i++)
                        if (points[i] == source) points[i] = target;
                }
                public bool Contain(int point) => points[0] == point || points[1] == point;
                public void Swap()
                {
                    int i = points[0];
                    points[0] = points[1];
                    points[1] = i;
                }
                public override string ToString()
                {
                    return "(" + points[0].ToString() + "," + points[1].ToString() + ") " + length.ToString();
                }
                public static bool operator ==(Line a, Line b)=> a.points[0] == b.points[0] && a.points[1] == b.points[1];
                public static bool operator !=(Line a, Line b) => !(a==b);
            }
            public List<int> points;
            public List<Line> lines;
            public Graph(List<int> points, List<Line> lines)
            {
                this.points = points;
                this.lines = lines;
            }
            public Graph(Graph g)
            {
                points = new List<int>(g.points);
                lines = new List<Line>();
                foreach (Line l in g.lines)
                    lines.Add(new Line(l));
            }
            public static void Delete(Graph g, int point)
            {
                g.points.Remove(point);
                int i = 0;
                while (i < g.lines.Count)
                {
                    if (g.lines[i].Contain(point)) g.lines.RemoveAt(i);
                    else i += 1;
                }
            }
            public void Delete(int point) => Delete(this, point);
            public Graph DeleteAC(int point)
            {
                Graph g = new Graph(this);
                g.Delete(point);
                return g;
            }
            public static void Delete(Graph g,Line line)
            {
                g.lines.Remove(line);
            }
            public void Delete(Line line) => Delete(this, line);
            public Graph DeleteAC(Line line)
            {
                int i = lines.IndexOf(line);
                Graph g = new Graph(this);
                Delete(g, g.lines[i]);
                return g;
            }
            /// <summary>
            /// 去重边
            /// </summary>
            public static void Simpify(Graph g)
            {
                int i = 0;
                foreach (Line line in g.lines)
                     if (line.points[0] > line.points[1]) line.Swap();
                
                while (i < g.lines.Count-1)
                {
                    int j = i + 1;
                    while (j < g.lines.Count)
                    {
                        if (g.lines[j] == g.lines[i]) g.lines.RemoveAt(j);
                        else j += 1;
                    }
                    i += 1;
                }
            }
            public void Simpify() => Simpify(this);
            public Graph SimpifyAC()
            {
                Graph g = new Graph(this);
                Simpify(g);
                return g;
            }
            public static void Absorb(Graph g, Line line)
            {
                int s = line.points[1], t = line.points[0];
                g.Delete(line);
                foreach (Line l in g.lines)
                    l.Replace(s , t);
                g.points.Remove(s);
                g.Simpify();
            }
            public void Absorb(Line line) => Absorb(this, line);
            public Graph AbsorbAC(Line line)
            {
                int i = lines.IndexOf(line);
                Graph g = new Graph(this);
                Absorb(g, g.lines[i]);
                return g;
            }
            public Graph Copy() => new Graph(this);
            public Multinomial GetColorM()
            {
                if (lines.Count > 0)
                {
                    Multinomial a = DeleteAC(lines[0]).GetColorM(),b = AbsorbAC(lines[0]).GetColorM();
                    return a - b;
                }
                else
                    return new Multinomial(new Item(1, 1, points.Count));
            }
        }
        #endregion

        #region Functions
        public static bool IsNote(char c) => c == '+' || c == '-' || c == '*' || c == '/' || c == '^' || c == '$'||c=='#';
        public static int RangeLimit(int a,int x,int b)
        {
            if (x < a) return a;
            if (x > b) return b;
            return x;
        }
        public static int GetItemIndex(string s, int i, bool front)
        {
            if (i < 0 || i >= s.Length) return -1;
            if (front)
            {
                while (i < s.Length && (IsAlpha(s[i]) || s[i] == '*' || s[i] == '/' || s[i] == '^')) i += 1;
                return i - 1;
            }
            else
            {
                while (i >= 0 && (IsAlpha(s[i]) || s[i] == '*' || s[i] == '/' || s[i] == '^')) i -= 1;
                return i + 1;
            }
        }
        public static int IndexOfWD(string s, char c, int deep)
        {
            int l = 0;
            for (int j = 0; j < s.Length; j++)
            {
                if (s[j] == '(') l += 1;
                else if (s[j] == ')') l -= 1;
                if (s[j] == c && l == deep) return j;
            }
            return -1;
        }
        public static int LastIndexOfWD(string s, char c, int deep)
        {
            int l = 0;
            for (int j = s.Length - 1; j >= 0; j--)
            {
                if (s[j] == '(') l += 1;
                else if (s[j] == ')') l -= 1;
                if (s[j] == c && l == deep) return j;
            }
            return -1;
        }
        public static int GetMulDeep(string s, int i)
        {
            int l = 0;
            for (int j = 0; j <= i; j++)
            {
                if (s[j] == '(') l += 1;
                else if (s[j] == ')') l -= 1;
            }
            return l;
        }
        public static QNum GetQNumFromIndex(string s, int i, bool front = true)
        {
            if (i == -1) return QNum.ToQNumWP(s);
            if (front)
            {
                if (s[i] == '(') return GetQNumFromIndex(s.Substring(i + 1, MatchKuo(s, i) - i - 1), -1);
                return new QNum(MatchNum(s, i));
            }
            else
            {
                if (s[i] == ')')
                {
                    int l = MatchKuo(s, i);
                    return GetQNumFromIndex(s.Substring(l + 1, i - l - 1), -1);
                }
                return new QNum(MatchNum(s, i, false));
            }
        }
        public static int GetPowDivitor(int n, int p)
        {
            List<NNumDivis> nu = NumFact(n);
            if (nu == null) return 1;
            int re = 1;
            foreach (NNumDivis x in nu)
            {
                if (x.Power >= p) re *= Pow(x.Num, x.Power / p);
            }
            return re;
        }
        public static Range GetNumRange(string s, int i)
        {
            int l = i;
            while (IsAlpha(s[l])) l -= 1;
            while (IsAlpha(s[i])) i += 1;
            return new Range(l + 1, i - 1);
        }
        public static List<PointS> GetPointsFromValue(IList<QNum> Values, QNum start, QNum step)
        {
            List<PointS> re = new List<PointS>();
            foreach (QNum qNum in Values)
            {
                re.Add(new PointS(start, qNum));
                start += step;
            }
            return re;
        }
        /// <summary>
        /// 转换为Int，计算^幂、*乘,()
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static int ToIntWP(string s)
        {
            if (s.Length == 1)
            {
                if (s == "+") return 1;
                if (s == "-") return -1;
                return s[0] - '0';
            }
            int i = s.IndexOf('('), l;
            if (i != -1)
            {
                l = MatchKuo(s, i);
                return ToIntWP(s.Substring(0, i) + (i > 0 && IsAlpha(s[i - 1]) ? "*" : "") + ToIntWP(s.Substring(i + 1, l - i - 1)) + (l < s.Length - 1 && IsAlpha(s[l + 1]) ? "*" : "") + s.Substring(l + 1));
            }
            i = s.IndexOf('+');
            if (i != -1 && i != 0) return ToIntWP(s.Substring(0, i)) + ToIntWP(s.Substring(i + 1));
            i = s.LastIndexOf('-');
            if (i != -1 && i != 0 && IsAlpha(s[i - 1])) return ToIntWP(s.Substring(0, i)) - ToIntWP(s.Substring(i + 1));
            i = s.LastIndexOf('*');
            if (i != -1) return ToIntWP(s.Substring(0, i)) * ToIntWP(s.Substring(i + 1));
            i = s.LastIndexOf('/');
            if (i != -1) return ToIntWP(s.Substring(0, i)) / ToIntWP(s.Substring(i + 1));
            i = s.IndexOf('^');
            if (i != -1) return (int)Math.Pow(Convert.ToInt32(s.Substring(0, i)), Convert.ToInt32(s.Substring(i + 1)));
            return Convert.ToInt32(s);
        }
        /// <summary>
        /// 返回从s[i]开始的完整的Int
        /// </summary>
        /// <param name="s"></param>
        /// <param name="i"></param>
        /// <returns></returns>
        public static int MatchNum(string s, int i, bool front = true)
        {
            int j = i;
            if (front)
            {

                while (j < s.Length && IsAlpha(s[j])) j++;
                return Convert.ToInt32(s.Substring(i, j - i));
            }
            else
            {
                while (j >= 0 && IsAlpha(s[j])) j--;
                return Convert.ToInt32(s.Substring(j + 1, i - j));
            }
        }
        /// <summary>
        /// 返回s[i]处的完整的Int
        /// </summary>
        /// <param name="s"></param>
        /// <param name="i"></param>
        /// <returns></returns>
        public static int MatchNumH(string s, int i)
        {
            int l = i;
            while (IsAlpha(s[l])) l -= 1;
            while (IsAlpha(s[i])) i += 1;
            return Convert.ToInt32(s.Substring(l + 1, i - l - 1));
        }
        /// <summary>
        /// 搜索匹配的字符串，返回第一位数序号，无则返回-1
        /// </summary>
        /// <param name="s"></param>
        /// <param name="m"></param>
        /// <returns></returns>
        public static int MatchString(string s, string m)
        {
            for (int i = 0; i < s.Length - m.Length; i++)
                if (s.Substring(i, m.Length) == m) return i;
            return -1;
        }
        /// <summary>
        /// 返回匹配的括号序号,无匹配输出-1
        /// </summary>
        /// <param name="s"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public static int MatchKuo(string s, int i)
        {
            int l = 0;
            if (s[i] == '(')
            {
                for (; i < s.Length; i++)
                {
                    if (s[i] == ')') l += 1;
                    else if (s[i] == '(') l -= 1;
                    if (l == 0) break;
                }
            }
            else if (s[i] == ')')
            {
                for (; i >= 0; i--)
                {
                    if (s[i] == ')') l += 1;
                    else if (s[i] == '(') l -= 1;
                    if (l == 0) break;
                }
            }
            else return -1;
            return l == 0 ? i : -1;
        }
        /// <summary>
        /// 质因数分解
        /// </summary>
        /// <param name="n"></param>
        /// <returns></returns>
        public static List<NNumDivis> NumFact(int n)
        {
            if (n <= 1) return null;
            int i = 0, l = 0;
            List<NNumDivis> result = new List<NNumDivis>();
            while (PrimeN[i] <= n)
            {
                if (n % PrimeN[i] == 0)
                {
                    if (result.Count == l) result.Add(new NNumDivis(PrimeN[i], 1));
                    else if (result[l].Num != PrimeN[i])
                    {
                        result.Add(new NNumDivis(PrimeN[i], 1));
                        l += 1;
                    }
                    else result[l].Power += 1;
                    n /= PrimeN[i];
                }
                else
                {
                    i += 1;
                    if (i >= PrimeNL)
                    {
                        result.Add(new NNumDivis(n, 1));
                        break;
                    }
                }

            }
            return result;
        }
        public static int Pow(int a, int b)
        {
            if (b < 1) return 1;
            if (b < 8) return (int)Math.Pow(a, b);
            int temp = 1, temp2 = a;
            while (b > 0)
            {
                if ((b & 1) == 0)
                {
                    a *= a;
                    b >>= 1;
                }
                else
                {
                    temp *= temp2;
                    b -= 1;
                }
            }
            return a * temp;
        }
        /// <summary>
        /// 返回n的所有因数，包含1和n
        /// </summary>
        /// <param name="n"></param>
        /// <returns></returns>
        public static List<int> AllFactorWT(int n, bool onlyPos = false)
        {
            List<int> re = new List<int>
            {
                1
            };
            if (!onlyPos) re.Add(-1);
            if (n < 0) n = -n;
            for (int i = 2; i <= n; i++)
                if (n % i == 0) { re.Add(i); if (!onlyPos) re.Add(-i); }
            return re;
        }
        /// <summary>
        /// 列表迭代器
        /// </summary>
        /// <param name="list">源</param>
        /// <param name="left">迭代的最小值</param>
        /// <param name="right">迭代的最大值</param>
        /// <param name="lrangel">迭代的范围，距离列表开始</param>
        /// <param name="lranger">迭代的范围，距离列表结束</param>
        /// <param name="step">迭代步长</param>
        /// <param name="DoLast">从最后一个数迭代</param>
        public static void ListYeild(List<int> list, int left, int right, int lrangel = 0, int lranger = 0, int step = 1, bool DoLast = true)
        {
            int i = DoLast ? list.Count - lranger - 1 : lrangel;
            while (true)
            {
                list[i] += step;
                if (list[i] > right || list[i] < left)
                {
                    list[i] = step > 0 ? left : right;
                    i += DoLast ? -1 : 1;
                    if (i < lrangel || i > list.Count - lranger - 1)
                    {
                        for (i = lrangel; i < list.Count - lranger; i++)
                            list[i] = step > 0 ? left : right;
                        return;
                    }
                }
                else return;
            }
        }
        /// <summary>
        /// 最大公约数
        /// </summary>
        /// <param name="n1"></param>
        /// <param name="n2"></param>
        /// <returns></returns>
        public static int Gcd(int n1, int n2)
        {
            if (n1 == 1 || n2 == 1) return 1;
            int temp;
            while (n2 != 0)
            {
                temp = n2;
                n2 = n1 % n2;
                n1 = temp;
            }
            return n1;
        }
        /// <summary>
        /// 最小公倍数
        /// </summary>
        /// <param name="n1"></param>
        /// <param name="n2"></param>
        /// <returns></returns>
        public static int Lcm(int n1, int n2) => n1 * n2 / Gcd(n1, n2);
        /// <summary>
        /// 正弦转余弦
        /// </summary>
        /// <param name="sin"></param>
        /// <returns></returns>
        public static double SinToCos(double sin) => Math.Sqrt(1 - sin * sin);
        /// <summary>
        /// 正弦和
        /// </summary>
        /// <param name="sinA"></param>
        /// <param name="sinB"></param>
        /// <returns></returns>
        public static double SinSum(double sinA, double sinB) => sinA * Math.Sqrt(1 - sinB * sinB) + sinB * Math.Sqrt(1 - sinA * sinA);
        /// <summary>
        /// 返回分母最小公倍数
        /// </summary>
        /// <param name="rNums"></param>
        /// <returns></returns>
        public static int Nqisit(IList<QNum> rNums)
        {
            int r = 1;
            foreach (QNum a in rNums)
                r = Lcm(r, a.Down);
            return r;
        }
        /// <summary>
        /// 返回系数分母最小公倍数
        /// </summary>
        /// <param name="items"></param>
        /// <returns></returns>
        public static int Nqisit(IList<Item> items)
        {
            int r = items[0].qNum.Up > 0 ? 1 : -1;
            foreach (Item a in items)
                r = Lcm(r, a.qNum.Down);
            return r;
        }
        /// <summary>
        /// 返回系数分母最小公倍数
        /// </summary>
        /// <param name="items"></param>
        /// <returns></returns>
        public static int Nqisit(IList<ItemEX> items)
        {
            int r = items[0].qNum.Up > 0 ? 1 : -1;
            foreach (ItemEX a in items)
                r = Lcm(r, a.qNum.Down);
            return r;
        }
        /// <summary>
        /// List每个元素是否相等
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="len"></param>
        /// <returns></returns>
        public static bool IsEqualList(IList<byte> a, IList<byte> b, int len)
        {
            for (int i = 0; i < len; i++)
                if (a[i] != b[i]) return false;
            return true;
        }
        /// <summary>
        /// List每个元素是否相等
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="len"></param>
        /// <returns></returns>
        public static bool IsEqualList(IList<int> a, IList<int> b)
        {
            if (a.Count != b.Count) return false;
            for (int i = 0; i < a.Count; i++)
                if (a[i] != b[i]) return false;
            return true;
        }
        /// <summary>
        /// 是否为数字
        /// </summary>
        /// <param name="c"></param>
        /// <returns></returns>
        public static bool IsAlpha(char c) => c >= '0' && c <= '9';
        public static bool IsUnkNum(char c) => (c >= 'a' && c <= 'z')|| (c >= 'A' && c <= 'Z');
        public static bool IsItem(char c) => IsAlpha(c) || c == '/' || c == '^' || c == 'x';
        /// <summary>
        /// 是否为数字，可带有 - /
        /// </summary>
        /// <param name="c"></param>
        /// <returns></returns>
        public static bool IsQNum(char c) => c == '-' || c == '/' || IsAlpha(c);
        /// <summary>
        /// 将List中元素顺序颠倒
        /// </summary>
        /// <param name="s"></param>
        public static void OpstList(IList<byte> s)
        {
            int cl = s.Count / 2;
            byte t;
            for (int i = 0; i < cl; i++)
            {
                t = s[i];
                s[i] = s[s.Count - 1 - i];
                s[s.Count - 1 - i] = t;
            }
            return;
        }
        /// <summary>
        /// 在字符串中查找多个字符，并在之前（之后）加上字符
        /// </summary>
        /// <param name="s"></param>
        /// <param name="match">要匹配的字符</param>
        /// <param name="div">分隔字符</param>
        /// <param name="front">在匹配的字符前</param>
        /// <returns></returns>
        public static string Divider(string s, string match, string div = "|", bool front = true)
        {
            int i = 1;
            while (i < s.Length)
            {
                if (match.Contains(s[i].ToString()))
                {
                    s = s.Insert(front ? i : i + 1, div);
                    i += 2;
                    continue;
                }
                i += 1;
            }
            return s;
        }
        /// <summary>
        /// 是否为质数
        /// </summary>
        /// <param name="x"></param>
        /// <returns></returns>
        public static bool IsPrime(int x)
        {
            int i = 0;
            while (i < PrimeNL && x > PrimeN[i]) i++;
            return PrimeN[i] == x;
        }
        /// <summary>
        /// 返回n的每个数位,从高到低
        /// </summary>
        /// <param name="n"></param>
        /// <returns></returns>
        public static List<byte> IntToDigital(int n)
        {
            List<byte> re = new List<byte>();
            string s = n >= 0 ? n.ToString() : n.ToString().Substring(1);
            for (int i = 0; i < s.Length; i++)
                re.Add((byte)(s[i] - '0'));
            return re;
        }
        /// <summary>
        /// 返回n的位数
        /// </summary>
        /// <param name="n"></param>
        /// <returns></returns>
        public static byte IntRange(int n)
        {
            for (byte i = 0; i < SizeTableL; i++)
                if (n < SizeTable[i]) return (byte)(i + 1);
            return (byte)(SizeTableL + 1);
        }
        #endregion
    }

}
